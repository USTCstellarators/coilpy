
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>coilpy.sortedDict &#8212; coilpy 0.3.30 documentation</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    <p class="title logo__title">coilpy 0.3.30 documentation</p>
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    
    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <h1>Source code for coilpy.sortedDict</h1><div class="highlight"><pre>
<span></span><span class="c1"># file processed by 2to3</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">range</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">pickle</span> <span class="k">as</span> <span class="nn">pypickle</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">cPickle</span> <span class="k">as</span> <span class="nn">pickle</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">filecmp</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">difflib</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pprint</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;hide_ptrn&#39;</span><span class="p">,</span> <span class="s1">&#39;private_ptrn&#39;</span><span class="p">,</span> <span class="s1">&#39;comment_ptrn&#39;</span><span class="p">,</span> <span class="s1">&#39;comment_ptrn_in_brackets&#39;</span><span class="p">,</span> <span class="s1">&#39;number_ptrn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sortHuman&#39;</span><span class="p">,</span> <span class="s1">&#39;get_bases&#39;</span><span class="p">,</span>
    <span class="s1">&#39;parseBuildLocation&#39;</span><span class="p">,</span> <span class="s1">&#39;parseLocation&#39;</span><span class="p">,</span> <span class="s1">&#39;traverseLocation&#39;</span><span class="p">,</span> <span class="s1">&#39;buildLocation&#39;</span><span class="p">,</span> <span class="s1">&#39;setLocation&#39;</span><span class="p">,</span>
    <span class="s1">&#39;traverse&#39;</span><span class="p">,</span> <span class="s1">&#39;treeLocation&#39;</span><span class="p">,</span>
    <span class="s1">&#39;recursiveUpdate&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pretty_diff&#39;</span><span class="p">,</span> <span class="s1">&#39;prune_mask&#39;</span><span class="p">,</span>
    <span class="s1">&#39;dynaLoad&#39;</span><span class="p">,</span> <span class="s1">&#39;dynaLoadKey&#39;</span><span class="p">,</span> <span class="s1">&#39;dynaSave&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SortedDict&#39;</span><span class="p">,</span> <span class="s1">&#39;pickle&#39;</span><span class="p">,</span> <span class="s1">&#39;size_tree_objects&#39;</span>
<span class="p">]</span>

<span class="c1"># Useful patterns</span>
<span class="n">hide_ptrn</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^__.*__$&#39;</span><span class="p">)</span>
<span class="n">private_ptrn</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^_.*[^_]+$&#39;</span><span class="p">)</span>
<span class="n">comment_ptrn</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^__comment.*__$&#39;</span><span class="p">)</span>
<span class="n">comment_ptrn_in_brackets</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&#39;&#39;.*\[[&#39;&quot;]__comment.*__[&#39;&quot;]\].*&#39;&#39;&#39;</span><span class="p">)</span>
<span class="n">number_ptrn</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[-+]?\d*\.?\d+[eEdD][-+\d]+|[-+\d]+\.\d+|\d+&quot;</span><span class="p">)</span>

<span class="n">_special1</span><span class="o">=</span><span class="p">[]</span>




<span class="k">def</span> <span class="nf">isinstance_str</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    checks if an object is of a certain type by looking at the class name (not the class object)</span>
<span class="sd">    This is useful to circumvent the need to load import Python modules.</span>

<span class="sd">    :param inv: object of which to check the class</span>

<span class="sd">    :param cls: string or list of string with the name of the class(es) to be checked</span>

<span class="sd">    :return: True/False</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span> <span class="s1">&#39;__class__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">inv</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">inv</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="bp">cls</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="c1">#---------------------</span>
<span class="c1"># Delete leading zeros</span>
<span class="c1">#---------------------</span>
<span class="k">def</span> <span class="nf">delete_leading_zeros</span><span class="p">(</span><span class="n">number_str</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Delete leading zeros from array indices</span>

<span class="sd">    :param number_str: A string containing comma separated dimension indices and colon separated ranges and strides, such as &#39;008:010,0001:0002&#39;</span>

<span class="sd">    :return: String with leading zeros stripped, such as &#39;8:10,1:2&#39;</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">colon_split</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">colon_split</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;0&#39;</span>
                                  <span class="k">for</span> <span class="n">colon_split</span> <span class="ow">in</span> <span class="n">comma_split</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)])</span>
                                        <span class="k">for</span> <span class="n">comma_split</span> <span class="ow">in</span> <span class="n">number_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)])</span>

<div class="viewcode-block" id="sortHuman"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.sortHuman">[docs]</a><span class="k">def</span> <span class="nf">sortHuman</span><span class="p">(</span><span class="n">inStr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sort the given list the way that humans expect&quot;&quot;&quot;</span>
    <span class="n">outStr</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">inStr</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">tmp</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">number_ptrn</span><span class="p">,</span><span class="n">outStr</span><span class="p">)</span>
    <span class="n">outStr</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">number_ptrn</span><span class="p">,</span><span class="s1">&#39;</span><span class="se">\1</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">outStr</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">kn</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">:</span>
        <span class="n">kn</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[dD]&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">,</span><span class="n">kn</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">outStr</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\1</span><span class="s1">&#39;</span><span class="p">,</span><span class="nb">format</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">kn</span><span class="p">),</span><span class="s2">&quot;+040.16f&quot;</span><span class="p">),</span><span class="n">outStr</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="n">outStr</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="n">outStr</span><span class="p">)</span>
    <span class="n">outStr</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;\+&#39;</span><span class="p">,</span><span class="s1">&#39;p&#39;</span><span class="p">,</span><span class="n">outStr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">outStr</span></div>

<span class="k">def</span> <span class="nf">_insort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">caseInsensitive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">lo</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">hi</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span><span class="o">+</span><span class="n">hi</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">caseInsensitive</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">&lt;</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">caseInsensitive</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]):</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">a</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="get_bases"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.get_bases">[docs]</a><span class="k">def</span> <span class="nf">get_bases</span><span class="p">(</span><span class="n">clss</span><span class="p">,</span><span class="n">tp</span><span class="o">=</span><span class="p">[]):</span>
    <span class="s2">&quot;Returns a list of strings describing the dependencies of a class&quot;</span>
    <span class="k">if</span> <span class="n">tp</span><span class="o">==</span><span class="p">[]:</span>
        <span class="n">tp</span><span class="o">=</span><span class="p">[</span><span class="n">clss</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>
    <span class="n">bases</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">clss</span><span class="p">,</span> <span class="s1">&#39;__bases__&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">bases</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="n">tp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="n">get_bases</span><span class="p">(</span><span class="n">item</span><span class="p">,</span><span class="n">tp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tp</span></div>


<span class="k">def</span> <span class="nf">different</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Evaluates if two objects are different</span>

<span class="sd">    :param a: first object to compare</span>

<span class="sd">    :param b: second object to compare</span>

<span class="sd">    :param precision: relative precision to which objects are compared</span>

<span class="sd">    :return: integer to indicate equal (0) or different (1)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">isinstance_str</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;OMFITexpression&#39;</span><span class="p">,</span> <span class="s1">&#39;OMFITiterableExpression&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">isinstance_str</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;OMFITexpression&#39;</span><span class="p">,</span> <span class="s1">&#39;OMFITiterableExpression&#39;</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">expression</span><span class="o">!=</span><span class="n">b</span><span class="o">.</span><span class="n">expression</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">a</span><span class="o">.</span><span class="vm">__class__</span><span class="o">!=</span><span class="n">b</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="s1">&#39;filename&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="s1">&#39;filename&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">filecmp</span><span class="o">.</span><span class="n">cmp</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">filecmp</span><span class="o">.</span><span class="n">cmp</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span><span class="n">shallow</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">filename</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">filename</span><span class="p">)[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">precision</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="mi">0</span>


<div class="viewcode-block" id="parseLocation"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.parseLocation">[docs]</a><span class="k">def</span> <span class="nf">parseLocation</span><span class="p">(</span><span class="n">inv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse string representation of the dictionary path and return list including root name</span>
<span class="sd">    This function can parse things like: OMFIT[&#39;asd&#39;][u&#39;aiy&#39; ][&quot;[  &#39;bla&#39;][&#39;asa&#39;]&quot;][3][1:5]</span>

<span class="sd">    :param inv: string representation of the dictionary path</span>

<span class="sd">    :return: list of dictionary keys including rootname</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># look for matching dictionary blocks with matching quotes</span>
    <span class="n">inv</span> <span class="o">=</span> <span class="n">inv</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">quote</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">starts_at</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">splits</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">k</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">char</span><span class="o">=</span><span class="kc">None</span>
    <span class="k">while</span> <span class="n">k</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">inv</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">inv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39; </span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">:</span>
            <span class="n">new_char</span><span class="o">=</span><span class="n">inv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">new_char</span> <span class="o">==</span> <span class="s1">&#39;[&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">quote</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inv</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">]:</span>
                <span class="n">quote</span> <span class="o">=</span> <span class="n">inv</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">inv</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="s1">&#39;bru&#39;</span> <span class="ow">and</span> <span class="n">inv</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">]:</span>
                <span class="n">quote</span> <span class="o">=</span> <span class="n">inv</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">quote</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">starts_at</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">inv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;]&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">quote</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="n">last_char</span> <span class="o">==</span> <span class="n">quote</span><span class="p">):</span>
            <span class="n">quote</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">splits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inv</span><span class="p">[</span><span class="n">starts_at</span><span class="p">:</span><span class="n">k</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">inv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39; </span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">:</span>
            <span class="n">last_char</span><span class="o">=</span><span class="n">inv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span>
    <span class="c1"># if quote was not closed then the parentheses do not match</span>
    <span class="k">if</span> <span class="n">quote</span><span class="p">:</span>
        <span class="k">raise</span> <span class="p">(</span><span class="ne">SyntaxError</span><span class="p">(</span><span class="s1">&#39;Unbalanced parentheses in &#39;</span> <span class="o">+</span> <span class="n">inv</span><span class="p">))</span>
    <span class="c1"># eval splits</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">splits</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">splits</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                <span class="n">splits</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">inv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">splits</span></div>


<div class="viewcode-block" id="buildLocation"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.buildLocation">[docs]</a><span class="k">def</span> <span class="nf">buildLocation</span><span class="p">(</span><span class="n">inv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assemble list of keys into dictionary path string</span>

<span class="sd">    :param inv: list of dictionary keys including rootname</span>

<span class="sd">    :return: string representation of the dictionary path</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tmp</span><span class="o">=</span><span class="n">inv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">inv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">item</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;[a-zA-Z]&#39;</span><span class="p">,</span><span class="n">item</span><span class="p">):</span>
                <span class="n">tmp</span><span class="o">+=</span><span class="s1">&#39;[&#39;</span><span class="o">+</span><span class="n">item</span><span class="o">+</span><span class="s1">&#39;]&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp</span><span class="o">+=</span><span class="s1">&#39;[&#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;]&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">+=</span><span class="s1">&#39;[&#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;]&#39;</span>
    <span class="k">return</span> <span class="n">tmp</span></div>


<div class="viewcode-block" id="setLocation"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.setLocation">[docs]</a><span class="k">def</span> <span class="nf">setLocation</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">globals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">locals</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">location</span> <span class="o">=</span> <span class="n">parseLocation</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
    <span class="nb">eval</span><span class="p">(</span><span class="n">buildLocation</span><span class="p">(</span><span class="n">location</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span><span class="nb">globals</span><span class="p">,</span><span class="nb">locals</span><span class="p">)[</span><span class="n">location</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">value</span></div>

<div class="viewcode-block" id="parseBuildLocation"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.parseBuildLocation">[docs]</a><span class="k">def</span> <span class="nf">parseBuildLocation</span><span class="p">(</span><span class="n">inv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DEPRECATED: use `parseLocation` and `buildLocation` functions instead</span>

<span class="sd">    Function to handle locations in the OMFIT tree (i.e. python dictionaries)</span>

<span class="sd">    :param inv: input location</span>

<span class="sd">    :return:</span>

<span class="sd">    * if `inv` is a string, then the dictionary path is split and a list is returned (Note that this function strips the root name)</span>

<span class="sd">    * if it&#39;s a list, then the dictionary path is assembled and a string is returned (Note that this function assumes that the root name is missing)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">parseLocation</span><span class="p">(</span><span class="n">inv</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">buildLocation</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">inv</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;parseBuildLocation accepts either a string or a list&#39;</span><span class="p">))</span></div>


<div class="viewcode-block" id="traverseLocation"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.traverseLocation">[docs]</a><span class="k">def</span> <span class="nf">traverseLocation</span><span class="p">(</span><span class="n">inv</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    returns list of locations to reach input location</span>

<span class="sd">    :param inv: string representation of the dictionary path</span>

<span class="sd">    :return: list of locations including rootname to reach input location</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">tmp</span><span class="o">=</span><span class="n">parseLocation</span><span class="p">(</span><span class="n">inv</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">buildLocation</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span></div>


<div class="viewcode-block" id="traverse"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.traverse">[docs]</a><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">onlyDict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">onlyLeaf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skipDynaLoad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">noSubmodules</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">traverse_classes</span><span class="o">=</span><span class="p">(</span><span class="nb">dict</span><span class="p">,)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a string or list of strings describing the path of every entry/subentries in the dictionary</span>

<span class="sd">    :param string: string to be appended in front of all entries</span>

<span class="sd">    :param level: maximum depth</span>

<span class="sd">    :param split: split the output string into a list of strings</span>

<span class="sd">    :param onlyDict: return only dictionary entries (can be a tuple of classes)</span>

<span class="sd">    :param onlyLeaf: return only non-dictionary entries (can be a tuple of classes)</span>

<span class="sd">    :param skipDynaLoad: skip entries that have .dynaLoad==True</span>

<span class="sd">    :param noSubmodules: controls whether to traverse submodules or not</span>

<span class="sd">    :param traverse_classes: tuple of classes to traverse</span>

<span class="sd">    :return: string or list of string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">string_in</span><span class="o">=</span><span class="n">string</span>
    <span class="n">string_out</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
        <span class="n">keys</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">keys</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">keys</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">kid</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="n">kidName</span><span class="o">=</span><span class="s2">&quot;[&quot;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">kid</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;]&quot;</span>
        <span class="n">string</span><span class="o">=</span><span class="n">string_in</span><span class="o">+</span><span class="n">kidName</span>
        <span class="c1"># skip also expressions when skipDynaLoad</span>
        <span class="k">if</span> <span class="n">skipDynaLoad</span> <span class="ow">and</span> <span class="n">isinstance_str</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;OMFITexpression&#39;</span><span class="p">,</span> <span class="s1">&#39;OMFITiterableExpression&#39;</span><span class="p">]):</span>
            <span class="k">continue</span>
        <span class="c1"># mention this entry according to `onlyDict` and `onlyLeaf` filters</span>
        <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="n">onlyDict</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">onlyLeaf</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">onlyDict</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">],</span><span class="n">traverse_classes</span><span class="p">))</span> <span class="ow">or</span>
            <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">onlyDict</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">],</span><span class="n">onlyDict</span><span class="p">))</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">onlyLeaf</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">],</span><span class="n">traverse_classes</span><span class="p">))</span> <span class="ow">or</span>
            <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">onlyLeaf</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">],</span><span class="n">onlyLeaf</span><span class="p">))</span>
           <span class="p">):</span>
            <span class="n">string_out</span><span class="o">+=</span><span class="n">string</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="c1"># do not go deeper if skipDynaLoad and the file has not been loaded</span>
        <span class="k">if</span> <span class="n">skipDynaLoad</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">],</span><span class="s1">&#39;dynaLoad&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">]</span><span class="o">.</span><span class="n">dynaLoad</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="c1"># go deeper</span>
        <span class="k">if</span> <span class="n">noSubmodules</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">classes.omfit_base</span> <span class="kn">import</span> <span class="n">OMFITmodule</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">],</span><span class="n">traverse_classes</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onlyDict</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">],</span><span class="n">onlyDict</span><span class="p">))</span> <span class="ow">and</span> <span class="n">level</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">])</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">noSubmodules</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">],</span><span class="n">OMFITmodule</span><span class="p">)):</span>
            <span class="n">level</span><span class="o">-=</span><span class="mi">1</span>
            <span class="n">string_out</span><span class="o">+=</span><span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">],</span><span class="n">string</span><span class="p">,</span><span class="n">level</span><span class="p">,</span><span class="kc">False</span><span class="p">,</span><span class="n">onlyDict</span><span class="p">,</span><span class="n">onlyLeaf</span><span class="p">,</span><span class="n">skipDynaLoad</span><span class="p">,</span><span class="n">noSubmodules</span><span class="p">,</span><span class="n">traverse_classes</span><span class="p">)</span>
            <span class="n">level</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">split</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">string_out</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">string_out</span></div>

<div class="viewcode-block" id="treeLocation"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.treeLocation">[docs]</a><span class="k">def</span> <span class="nf">treeLocation</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="s1">&#39;_OMFITcopyOf&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">location</span><span class="o">.</span><span class="n">_OMFITcopyOf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">location</span><span class="o">.</span><span class="n">_OMFITcopyOf</span><span class="p">()</span>

    <span class="n">_nil</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">memo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">location</span><span class="p">),</span> <span class="n">_nil</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_nil</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">y</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">location</span><span class="p">,</span><span class="s1">&#39;_OMFITparent&#39;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">location</span><span class="o">.</span><span class="n">_OMFITkeyName</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
            <span class="n">location</span><span class="o">.</span><span class="n">_OMFITparent</span><span class="o">=</span><span class="kc">None</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1">#this is for objects which do not accept ._OMFITparent (e.g. int, None, float,...)</span>
            <span class="c1">#these are only leafs in the tree and do not need their location in the tree</span>
            <span class="c1">#to function anyways.</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">location</span><span class="o">.</span><span class="n">_OMFITparent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#this is when to treat the head node</span>
        <span class="n">tmp</span><span class="o">=</span><span class="p">[</span><span class="n">location</span><span class="o">.</span><span class="n">_OMFITkeyName</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#this is for all of the middle nodes</span>
        <span class="n">tmp</span><span class="o">=</span><span class="n">treeLocation</span><span class="p">(</span><span class="n">location</span><span class="o">.</span><span class="n">_OMFITparent</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tmp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">location</span><span class="o">.</span><span class="n">_OMFITkeyName</span><span class="p">)</span>

    <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">location</span><span class="p">)]</span> <span class="o">=</span> <span class="n">tmp</span>
    <span class="n">_keep_alive</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tmp</span></div>

<span class="k">def</span> <span class="nf">_keep_alive</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Keeps a reference to the object x in the memo.</span>

<span class="sd">    Because we remember objects by their id, we have</span>
<span class="sd">    to assure that possibly temporary objects are kept</span>
<span class="sd">    alive by referencing them.</span>
<span class="sd">    We store a reference at the id of the memo, which should</span>
<span class="sd">    normally not be used unless someone tries to deepcopy</span>
<span class="sd">    the memo itself...</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">memo</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="c1"># aha, this is the first one :-)</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">memo</span><span class="p">)]</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>


<div class="viewcode-block" id="recursiveUpdate"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.recursiveUpdate">[docs]</a><span class="k">def</span> <span class="nf">recursiveUpdate</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">overWrite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Recursive update of dictionary A based on data from dictionary B</span>

<span class="sd">    :param A: dictionary A</span>

<span class="sd">    :param B: dictionary B</span>

<span class="sd">    :param overWrite: force overwrite of duplicates</span>

<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">f_traverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">kid</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">kid</span><span class="p">],</span><span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">kid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">kid</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="n">kid</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
                <span class="n">f_traverse</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">kid</span><span class="p">],</span><span class="n">B</span><span class="p">[</span><span class="n">kid</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">overWrite</span> <span class="ow">or</span> <span class="n">kid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">kid</span><span class="p">]</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">kid</span><span class="p">])</span>
    <span class="n">f_traverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span></div>

<div class="viewcode-block" id="pretty_diff"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.pretty_diff">[docs]</a><span class="k">def</span> <span class="nf">pretty_diff</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">ptrn</span><span class="o">=</span><span class="p">{}):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    generate &quot;human readable&quot; dictionary output from SortedDict.diff()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="nb">dict</span><span class="p">):</span>
            <span class="n">ptrn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">SortedDict</span><span class="p">()</span>
            <span class="n">pretty_diff</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">],</span><span class="n">ptrn</span><span class="o">=</span><span class="n">ptrn</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ptrn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ptrn</span></div>

<div class="viewcode-block" id="prune_mask"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.prune_mask">[docs]</a><span class="k">def</span> <span class="nf">prune_mask</span><span class="p">(</span><span class="n">what</span><span class="p">,</span><span class="n">ptrn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    prune dictionary structure based on mask</span>
<span class="sd">    The mask can be in the form of of a `pretty_diff` dictionary or a list of `traverse` strings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ptrn</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">what</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">ptrn</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">del</span> <span class="n">what</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">what</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ptrn</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="nb">dict</span><span class="p">):</span>
                <span class="n">prune_mask</span><span class="p">(</span><span class="n">what</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">ptrn</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">what</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ptrn</span><span class="p">,(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>

        <span class="n">ptrn</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">ptrn</span><span class="p">)</span>

        <span class="c1">#disregard non-existent paths</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">item</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">ptrn</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;what&#39;</span><span class="o">+</span><span class="n">item</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">ptrn</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="c1">#expand subtrees</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">ptrn</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;what&#39;</span><span class="o">+</span><span class="n">item</span><span class="p">),</span><span class="n">SortedDict</span><span class="p">):</span>
                <span class="n">ptrn</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">item</span><span class="o">+</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;what&#39;</span><span class="o">+</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="n">traverse</span><span class="p">()])</span>

        <span class="c1">#expand add parents</span>
        <span class="n">ptrn</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">ptrn</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">ptrn</span><span class="p">):</span>
            <span class="n">rootName</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">parseLocation</span><span class="p">(</span><span class="n">item</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">rootName</span><span class="o">=</span><span class="n">rootName</span><span class="o">+</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
                <span class="n">ptrn</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">buildLocation</span><span class="p">(</span><span class="n">rootName</span><span class="p">))</span>

        <span class="c1">#do the pruning</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">what</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ptrn</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">exec</span><span class="p">(</span><span class="s1">&#39;del what&#39;</span><span class="o">+</span><span class="n">item</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">())</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="n">what</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;prune_mask: only list/tuple/dict supported&#39;</span><span class="p">))</span></div>

<div class="viewcode-block" id="size_tree_objects"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.size_tree_objects">[docs]</a><span class="k">def</span> <span class="nf">size_tree_objects</span><span class="p">(</span><span class="n">location</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns file sizes of objects in the dictionary based on the size of their filename attribute</span>

<span class="sd">    :param location: string of the tree location to be analyzed</span>

<span class="sd">    :return: dictionary with locations sorted by size</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tmp</span><span class="o">=</span><span class="n">traverse</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">location</span><span class="p">),</span><span class="n">onlyDict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">skipDynaLoad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">sizes</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">location</span><span class="o">+</span><span class="n">item</span><span class="p">),</span><span class="s1">&#39;filename&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="n">location</span><span class="o">+</span><span class="n">item</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">filename</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">size</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">st_size</span>
                <span class="k">if</span> <span class="n">size</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">:</span>
                    <span class="n">sizes</span><span class="p">[</span><span class="n">size</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">sizes</span><span class="p">[</span><span class="n">size</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">location</span><span class="o">+</span><span class="n">item</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">_excp</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error sizing object </span><span class="si">%s</span><span class="s1"> : </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">location</span><span class="o">+</span><span class="n">item</span><span class="p">,</span><span class="nb">repr</span><span class="p">(</span><span class="n">_excp</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">sizes</span></div>

<div class="viewcode-block" id="dynaLoad"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.dynaLoad">[docs]</a><span class="k">def</span> <span class="nf">dynaLoad</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Decorator which calls `_dynaLoad` method</span>

<span class="sd">    :param f: function to decorate</span>

<span class="sd">    :return: decorated function</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dynamicLoading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dynaLoad</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dynamicLoading</span></div>

<div class="viewcode-block" id="dynaLoadKey"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.dynaLoadKey">[docs]</a><span class="k">def</span> <span class="nf">dynaLoadKey</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Decorator which calls `_dynaLoad` method only if key is not found</span>

<span class="sd">    :param f: function to decorate</span>

<span class="sd">    :return: decorated function</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dynamicLoading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dynaLoad</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dynamicLoading</span></div>

<div class="viewcode-block" id="dynaSave"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.dynaSave">[docs]</a><span class="k">def</span> <span class="nf">dynaSave</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Decorator which calls `_dynaSave` method</span>

<span class="sd">    :param f: function to decorate</span>

<span class="sd">    :return: decorated function</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">doNothing</span><span class="p">():</span>
        <span class="k">pass</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dynamicSaving</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;readOnly&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">readOnly</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;modifyOriginal&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">modifyOriginal</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">samefile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">doNothing</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;_save_by_copy&#39;</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_by_copy</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynaSave</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">doNothing</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dynamicSaving</span></div>

<span class="k">def</span> <span class="nf">_docFromDict</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Use the same docstring as for dict</span>

<span class="sd">    :param f: function to decorate</span>

<span class="sd">    :return: decorated function</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="vm">__doc__</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">f</span>

<div class="viewcode-block" id="SortedDict"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict">[docs]</a><span class="k">class</span> <span class="nc">SortedDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="c1"># originally inspired from django/trunk/django/utils/datastructures.py @ 17464</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A dictionary that keeps its keys in the order in which they&#39;re inserted</span>
<span class="sd">    </span>
<span class="sd">    :param data: A dict object or list of (key,value) tuples from which to initialize the new SortedDict object</span>
<span class="sd">    </span>
<span class="sd">    :param \**kw: Optional keyword arguments given below</span>

<span class="sd">    kw:</span>
<span class="sd">        :param caseInsensitive: (bool)  If True, allows self[&#39;UPPER&#39;] to yield self[&#39;upper&#39;].</span>

<span class="sd">        :param sorted: (bool) If True, keep keys sorted alphabetically, instead of by insertion order.</span>

<span class="sd">        :param limit: (int) keep only the latest `limit` number of entries (useful for data cashes)</span>

<span class="sd">        :param dynaLoad: (bool) Not sure what this does</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">SortedDict</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">instance</span><span class="o">.</span><span class="n">keyOrder</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_OMFITkeyName</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_OMFITparent</span><span class="o">=</span><span class="kc">None</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">caseInsensitive</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;caseInsensitive&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">sorted</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sorted&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">limit</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;limit&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">dynaLoad</span><span class="o">=</span><span class="kc">False</span>

        <span class="k">return</span> <span class="n">instance</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_OMFITkeyName</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_OMFITparent</span><span class="o">=</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">caseInsensitive</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;caseInsensitive&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sorted&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;limit&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dynaLoad</span><span class="o">=</span><span class="kc">False</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
            <span class="c1"># Unfortunately we need to be able to read a generator twice.  Once</span>
            <span class="c1"># to get the data into self with our super().__init__ call and a</span>
            <span class="c1"># second time to setup keyOrder correctly</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">value</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dynaLoad</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dynaLoad&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dynaLoad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        call `load` function if object has `dynaLoad` attribute set to True</span>
<span class="sd">        after calling `load` function the `dynaLoad` attribute is set to False</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynaLoad</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dynaLoad</span><span class="o">=</span><span class="kc">False</span>
            <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="o">!=</span><span class="s1">&#39;load&#39;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># import sys,traceback</span>
                    <span class="c1"># filename=str(id(self))</span>
                    <span class="c1"># if hasattr(self,&#39;filename&#39;):</span>
                    <span class="c1">#     filename=self.filename</span>
                    <span class="c1"># print(&#39;&#39;,file=sys.__stderr__)</span>
                    <span class="c1"># print(&#39;--------------------&#39;,file=sys.__stderr__)</span>
                    <span class="c1"># print(&#39;Dynamic load &#39;+os.path.split(filename)[1]+&#39;\t\t(%s)&#39;%str(f),file=sys.__stderr__)</span>
                    <span class="c1"># print(&#39;--------------------&#39;,file=sys.__stderr__)</span>
                    <span class="c1"># traceback.print_stack(file=sys.__stderr__)</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">_excp_load</span><span class="p">:</span>
                    <span class="c1"># If an error occurs during loading</span>
                    <span class="c1"># Clear and reset the dynamic load switch to allow re-tries</span>
                    <span class="c1"># note: errors could occur because user stops the process</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">_excp_clear</span><span class="p">:</span>
                        <span class="c1"># if clear() fails, then its exception should be printd but not raised.</span>
                        <span class="c1"># the user is interested in the original exception raised by load().</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The clear() method raised an exception: &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">_excp_clear</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dynaLoad</span><span class="o">=</span><span class="kc">True</span>
                    <span class="k">raise</span> <span class="n">_excp_load</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_dynaSave</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is meant to be called in the .save() function of objects of the class</span>
<span class="sd">        `OMFITobject` that support dynamic loading. The idea is that if an object has not</span>
<span class="sd">        been loaded, then its file representation has not changed and the original file can be resued.</span>
<span class="sd">        This function returns True/False to say if it was successful at saving.</span>
<span class="sd">        If True, then the original .save() function can return, otherwise it should go through</span>
<span class="sd">        saving the data from memory to file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynaLoad</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;link&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;filename&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dynamic save: &#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span><span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">topic</span><span class="o">=</span><span class="s1">&#39;save&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link</span><span class="p">)</span> <span class="o">!=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">filecmp</span><span class="o">.</span><span class="n">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span><span class="n">shallow</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">link</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
                            <span class="k">return</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">OMFITaux</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;hardLinks&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">):</span>
                            <span class="n">os</span><span class="o">.</span><span class="n">link</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hard link: </span><span class="si">%s</span><span class="s1"> --&gt; </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">),</span><span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">topic</span><span class="o">=</span><span class="s1">&#39;save&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span><span class="p">(</span><span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;skip&#39;</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link</span><span class="p">):</span>
                            <span class="n">shutil</span><span class="o">.</span><span class="n">copytree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">shutil</span><span class="o">.</span><span class="n">copy2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">link</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">_excp</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error dynamic save: &#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">_excp</span><span class="p">))</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_OMFIT&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;OMFIT&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;bad attribute `</span><span class="si">%s</span><span class="s1">`&#39;</span> <span class="o">%</span> <span class="n">attr</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynaLoad</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;__save_kw__&#39;</span><span class="p">,</span> <span class="s1">&#39;__tree_repr__&#39;</span><span class="p">,</span> <span class="s1">&#39;modifyOriginal&#39;</span><span class="p">,</span> <span class="s1">&#39;readOnly&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="s1">&#39;getattr_infiniteloop_block&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;USER&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;meneghini&#39;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> dynaloading because </span><span class="si">%s</span><span class="s1"> attribute was requested&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
                    <span class="n">print_stack</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;getattr_infiniteloop_block&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dynaLoad</span><span class="p">()</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;getattr_infiniteloop_block&#39;</span><span class="p">]</span>

        <span class="k">raise</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;bad attribute `</span><span class="si">%s</span><span class="s1">`&#39;</span> <span class="o">%</span> <span class="n">attr</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_setLocation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_OMFITparent&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_OMFITparent</span><span class="p">:</span>

            <span class="c1"># check if the parent is the OMFIT tree</span>
            <span class="n">inOMFITtree</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">while</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s1">&#39;_OMFITparent&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_OMFITparent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_OMFITkeyName</span> <span class="o">==</span> <span class="s1">&#39;OMFIT&#39;</span><span class="p">:</span>
                    <span class="n">inOMFITtree</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_OMFITparent</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="ow">and</span> <span class="n">inOMFITtree</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">isinstance_str</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;OMFITexpression&#39;</span><span class="p">,</span> <span class="s1">&#39;OMFITiterableExpression&#39;</span><span class="p">]):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span><span class="o">.</span><span class="n">_OMFITkeyName</span> <span class="o">=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
                <span class="n">value</span><span class="o">.</span><span class="n">_OMFITparent</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="n">value</span><span class="o">.</span><span class="n">_OMFITcopyOf</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># this copy goes directly into the tree, so we can set it to None</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="k">return</span> <span class="n">value</span>

    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SortedDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>

    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span>

    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_checkSetitem</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">isinstance_str</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;OMFITexpression&#39;</span><span class="p">,</span> <span class="s1">&#39;OMFITiterableExpression&#39;</span><span class="p">]):</span>
            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;OMFITexpressions are not valid keys for &#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="n">keyL</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyCaseInsensitive</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keyL</span><span class="o">!=</span><span class="n">key</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">keyL</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">keyL</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;sorted&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span><span class="p">:</span>
                <span class="n">_insort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">caseInsensitive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span><span class="o">=</span><span class="n">key</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">SortedDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setLocation</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span> <span class="p">)</span>

        <span class="c1">#make whatever SortedDict is under a caseInsensitive SortedDict, caseInsensitive itself</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span><span class="n">SortedDict</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">caseInsensitive</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">caseInsensitive</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">caseInsensitive</span>

        <span class="c1">#if limit&gt;0 limit the number of entries</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">)</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">:</span>
            <span class="n">delkey</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">SortedDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">delkey</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">delkey</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_checkSetitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This method is provided so that subclasses can use it to either:</span>
<span class="sd">         1) change the key/value tuple as passed to the __setitem__ method</span>
<span class="sd">         2) raise an error because the key-value pair is not acceptable</span>

<span class="sd">        :param key: key as passed by the user to the __setitem__ method</span>

<span class="sd">        :param value: value as passed by the user to the __setitem__ method</span>

<span class="sd">        :return: updated (key, value) tuple</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span>

    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyCaseInsensitive</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SortedDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="c1">#does not need @dynaLoadKey, because functions that call _keyCaseInsensitive already do</span>
    <span class="k">def</span> <span class="nf">_keyCaseInsensitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;caseInsensitive&#39;</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">caseInsensitive</span><span class="o">=</span><span class="kc">False</span>
        <span class="n">found</span><span class="o">=</span><span class="n">key</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">caseInsensitive</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">keyL</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keyL</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">keyL</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                    <span class="n">found</span><span class="o">=</span><span class="n">keyL</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">found</span>

    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoadKey</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyCaseInsensitive</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SortedDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1">#if this instance has a fetch method, then call it and try it __getitem__ again</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;fetch&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fetch</span><span class="p">()</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SortedDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>

    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoadKey</span>
    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SortedDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyCaseInsensitive</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tmp</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[:</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;_OMFIT&#39;</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tmp</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">tmp</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
            <span class="c1">#old way of loading sortedDict</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">=</span><span class="n">tmp</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_setLocation</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#new way of loading sortedDict</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="o">=</span><span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">,</span><span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_setLocation</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="SortedDict.index"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.index">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns the index of the item</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyCaseInsensitive</span><span class="p">(</span><span class="n">item</span><span class="p">))</span></div>

    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">)</span>

<div class="viewcode-block" id="SortedDict.pop"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.pop">[docs]</a>    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyCaseInsensitive</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">SortedDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># Key wasn&#39;t in the dictionary in the first place. No problem.</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="SortedDict.popitem"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.popitem">[docs]</a>    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">popitem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">SortedDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="SortedDict.items"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.items">[docs]</a>    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span></div>

<div class="viewcode-block" id="SortedDict.iteritems"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.iteritems">[docs]</a>    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

<div class="viewcode-block" id="SortedDict.keys"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.keys">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">matching</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        returns the sorted list of keys in the dictionary</span>

<span class="sd">        :param filter: regular expression for filtering keys</span>

<span class="sd">        :param matching: boolean to indicate whether to return the keys that match (or not)</span>

<span class="sd">        :return: list of keys</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">[:]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">matching</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">kkk</span> <span class="k">for</span> <span class="n">kkk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">[:]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">kkk</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">kkk</span> <span class="k">for</span> <span class="n">kkk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">[:]</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">kkk</span><span class="p">))]</span></div>

<div class="viewcode-block" id="SortedDict.iterkeys"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.iterkeys">[docs]</a>    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">)</span></div>

<div class="viewcode-block" id="SortedDict.values"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.values">[docs]</a>    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">))</span></div>

<div class="viewcode-block" id="SortedDict.itervalues"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.itervalues">[docs]</a>    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

<div class="viewcode-block" id="SortedDict.update"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.update">[docs]</a>    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dict_</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">dict_</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setLocation</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="SortedDict.setdefault"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.setdefault">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The method setdefault() is similar to get(), but will set dict[key]=default if key is not already in dict</span>

<span class="sd">        :param key: key to be accessed</span>

<span class="sd">        :param default: default value if key does not exist</span>

<span class="sd">        :return: value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;sorted&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span><span class="p">:</span>
                <span class="n">_insort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">default</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

<div class="viewcode-block" id="SortedDict.get"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.get">[docs]</a>    <span class="nd">@_docFromDict</span>
    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

<div class="viewcode-block" id="SortedDict.value_for_index"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.value_for_index">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">value_for_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the value of the item at the given zero-based index&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span></div>

<div class="viewcode-block" id="SortedDict.insert"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.insert">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inserts the key, value pair before the item with the given index&quot;&quot;&quot;</span>
        <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyCaseInsensitive</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">index</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">value</span></div>

<div class="viewcode-block" id="SortedDict.copy"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.copy">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a copy of this object&quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">keyOrder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">[:]</span>
        <span class="k">return</span> <span class="n">obj</span></div>

    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns the keys in their sorted order&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;{</span><span class="si">%s</span><span class="s1">}&#39;</span> <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">%r</span><span class="s1">: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>

<div class="viewcode-block" id="SortedDict.clear"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.clear">[docs]</a>    <span class="nd">@_docFromDict</span>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SortedDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span> <span class="o">=</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="SortedDict.moveUp"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.moveUp">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">moveUp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Shift up in key list the item at a given index</span>

<span class="sd">        :param index: index to be shifted</span>

<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">index</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">))</span></div>

<div class="viewcode-block" id="SortedDict.moveDown"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.moveDown">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">moveDown</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Shift down in key list the item at a given index</span>

<span class="sd">        :param index: index to be shifted</span>

<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">index</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">+</span><span class="s1">&#39;(&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span><span class="o">+</span><span class="s1">&#39;)&#39;</span>

<div class="viewcode-block" id="SortedDict.across"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.across">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">across</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">returnKeys</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Aggregate objects across the tree</span>

<span class="sd">        :param what: string with the regular expression to be cut across</span>

<span class="sd">        :param sort: sorting of results alphabetically</span>

<span class="sd">        :param returnKeys: return keys of elements in addition to objects</span>

<span class="sd">        :return: list of objects or tuple with with objects and keys</span>

<span class="sd">        &gt;&gt; OMFIT[&#39;test&#39;]=OMFITtree()</span>
<span class="sd">        &gt;&gt; for k in range(5):</span>
<span class="sd">        &gt;&gt;   OMFIT[&#39;test&#39;][&#39;aaa&#39;+str(k)]=OMFITtree()</span>
<span class="sd">        &gt;&gt;   OMFIT[&#39;test&#39;][&#39;aaa&#39;+str(k)][&#39;var&#39;]=k</span>
<span class="sd">        &gt;&gt; OMFIT[&#39;test&#39;][&#39;bbb&#39;+str(k)]=-1</span>
<span class="sd">        &gt;&gt; print(OMFIT[&#39;test&#39;].across(&quot;[&#39;aaa*&#39;][&#39;var&#39;]&quot;))</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">location</span><span class="o">=</span><span class="n">parseBuildLocation</span><span class="p">(</span><span class="n">what</span><span class="p">)</span>
        <span class="n">keys</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="nb">repr</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">what</span><span class="o">=</span><span class="n">parseBuildLocation</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">what</span><span class="o">=</span><span class="s1">&#39;&#39;</span>

        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">index</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span><span class="n">keys</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)))</span>

        <span class="n">tmp</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">tmp_</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;tmp_&quot;</span><span class="o">+</span><span class="n">what</span><span class="p">))</span>
            <span class="n">tmp_</span>
        <span class="k">if</span> <span class="n">returnKeys</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tmp</span><span class="p">,[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">keys</span><span class="p">)[</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="nb">int</span><span class="p">)]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tmp</span></div>

<div class="viewcode-block" id="SortedDict.sort"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.sort">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param key: function that returns a string that is used for sorting or dictionary key whose content is used for sordting</span>

<span class="sd">        &gt;&gt; tmp=SortedDict()</span>
<span class="sd">        &gt;&gt; for k in range(5):</span>
<span class="sd">        &gt;&gt;     tmp[k]={}</span>
<span class="sd">        &gt;&gt;     tmp[k][&#39;a&#39;]=4-k</span>
<span class="sd">        &gt;&gt; # by dictionary key</span>
<span class="sd">        &gt;&gt; tmp.sort(key=&#39;a&#39;)</span>
<span class="sd">        &gt;&gt; # or equivalently</span>
<span class="sd">        &gt;&gt; tmp.sort(key=lambda x:tmp[x][&#39;a&#39;])</span>

<span class="sd">        :param \**kw: additional keywords passed to the underlying list sort command</span>

<span class="sd">        :return: sorted keys</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">sortHuman</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">key</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span></div>

<div class="viewcode-block" id="SortedDict.sort_class"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.sort_class">[docs]</a>    <span class="k">def</span> <span class="nf">sort_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">class_order</span><span class="o">=</span><span class="p">[</span><span class="nb">dict</span><span class="p">]):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        sort items based on their class</span>

<span class="sd">        :param class_order: list containing order of class</span>

<span class="sd">        :return: sorted keys</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">lst</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="p">:</span>
            <span class="n">oo</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">class_order</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">o</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">class_order</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">c</span><span class="p">):</span>
                    <span class="n">oo</span><span class="o">=</span><span class="n">o</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="s1">&#39;__class__&#39;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">o</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">class_order</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">==</span><span class="n">c</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span>
                        <span class="n">oo</span><span class="o">=</span><span class="n">o</span>
                        <span class="k">break</span>
            <span class="n">lst</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">oo</span><span class="p">,[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">class_order</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span><span class="o">+=</span><span class="n">lst</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyOrder</span></div>

<div class="viewcode-block" id="SortedDict.diff"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.diff">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ignoreComments</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignoreContent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skipClasses</span><span class="o">=</span><span class="p">(),</span> <span class="n">noloadClasses</span><span class="o">=</span><span class="p">(),</span> <span class="n">precision</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param other: other dictionary to compare to</span>

<span class="sd">        :param ignoreComments: ignore keys that start and end with &quot;__&quot; (e.g. &quot;__comment__&quot;)</span>

<span class="sd">        :param ignoreContent: ignore content of the objects</span>

<span class="sd">        :param skipClasses: list of class of objects to ignore</span>

<span class="sd">        :param noloadClasses: list of class of objects to not load</span>

<span class="sd">        :param precision: relative precision to which the comparison is carried out</span>

<span class="sd">        :param quiet: verbosity of the comparison</span>

<span class="sd">        :return: comparison dictionary</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#todo: should allow taking differences among any type of dictionary, not only sorted dict</span>

        <span class="c1">#use difflib.Differ (which operates on strings) to find out differences</span>
        <span class="n">selfEntries</span><span class="o">=</span><span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>
        <span class="n">otherEntries</span><span class="o">=</span><span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>
        <span class="n">tmp</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">difflib</span><span class="o">.</span><span class="n">Differ</span><span class="p">(</span><span class="n">linejunk</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">selfEntries</span><span class="p">,</span><span class="n">otherEntries</span><span class="p">))</span>
        <span class="n">keys</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">,[</span><span class="n">_f</span> <span class="k">for</span> <span class="n">_f</span> <span class="ow">in</span> <span class="p">[</span><span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">tmp</span> <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;?&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">_f</span><span class="p">]))</span>

        <span class="c1">#unique keys, keep the ordering, allow caseInsensitive</span>
        <span class="n">tmp</span><span class="o">=</span><span class="n">SortedDict</span><span class="p">(</span><span class="n">caseInsensitive</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">caseInsensitive</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
        <span class="n">keys</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">ignoreComments</span><span class="p">:</span>
            <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">comment_ptrn</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))]</span>

        <span class="n">ndiffs</span><span class="o">=</span><span class="mf">0.</span>
        <span class="n">switch</span><span class="o">=</span><span class="n">SortedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span> <span class="n">printi</span><span class="p">(</span><span class="s1">&#39;Compare: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">switch</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;added&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">]</span>
                <span class="n">ndiffs</span><span class="o">+=</span><span class="mf">1.</span>

            <span class="k">elif</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="n">switch</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;removed&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">]</span>
                <span class="n">ndiffs</span><span class="o">+=</span><span class="mf">1.</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span><span class="n">skipClasses</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">],</span><span class="n">skipClasses</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span><span class="n">noloadClasses</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">],</span><span class="n">noloadClasses</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span><span class="n">SortedDict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">],</span><span class="n">SortedDict</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">dynaLoad</span> <span class="ow">or</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">dynaLoad</span><span class="p">):</span>
                        <span class="n">switch</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;noLoad&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">]</span>
                        <span class="k">continue</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span><span class="n">SortedDict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">],</span><span class="n">SortedDict</span><span class="p">):</span>
                    <span class="n">tmp</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">ignoreComments</span><span class="o">=</span><span class="n">ignoreComments</span><span class="p">,</span> <span class="n">ignoreContent</span><span class="o">=</span><span class="n">ignoreContent</span><span class="p">,</span> <span class="n">skipClasses</span><span class="o">=</span><span class="n">skipClasses</span><span class="p">,</span> <span class="n">noloadClasses</span><span class="o">=</span><span class="n">noloadClasses</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]]):</span>
                        <span class="n">switch</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
                        <span class="n">ndiffs</span><span class="o">+=</span><span class="mf">1.</span>

                <span class="k">elif</span> <span class="ow">not</span> <span class="n">ignoreContent</span> <span class="ow">and</span> <span class="n">different</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span><span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">],</span><span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">):</span>
                    <span class="n">switch</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;changed&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">]</span>
                    <span class="n">ndiffs</span><span class="o">+=</span><span class="mf">1.</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">switch</span><span class="p">,</span><span class="kc">False</span><span class="p">,</span><span class="n">keys</span><span class="p">]</span></div>

<div class="viewcode-block" id="SortedDict.diffKeys"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.diffKeys">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">diffKeys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param other: other dictionary to compare to</span>

<span class="sd">        :return: floating point to indicate the ratio of keys that are similar</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#notice that selfKeys and otherKeys are generated with traverse() and do not include comment_ptrn_in_brackets</span>
        <span class="n">selfKeys</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">comment_ptrn_in_brackets</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))])</span>
        <span class="n">otherKeys</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">traverse</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">comment_ptrn_in_brackets</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selfKeys</span><span class="p">)</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">otherKeys</span><span class="p">):</span>
            <span class="n">keys</span><span class="o">=</span><span class="n">selfKeys</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keys</span><span class="o">=</span><span class="n">otherKeys</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.</span>

        <span class="n">ndiffs</span><span class="o">=</span><span class="mf">0.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selfKeys</span><span class="p">)</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">otherKeys</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">otherKeys</span><span class="p">:</span>
                <span class="n">ndiffs</span><span class="o">+=</span><span class="mf">1.</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">selfKeys</span><span class="p">)</span><span class="o">&gt;=</span><span class="nb">len</span><span class="p">(</span><span class="n">otherKeys</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">selfKeys</span><span class="p">:</span>
                <span class="n">ndiffs</span><span class="o">+=</span><span class="mf">1.</span>

        <span class="n">lk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0</span>
        <span class="n">lE</span><span class="o">=</span><span class="n">lk</span><span class="o">-</span><span class="n">ndiffs</span>
        <span class="k">if</span> <span class="n">lk</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">score</span><span class="o">=</span><span class="n">lE</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">lk</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">score</span><span class="o">=</span><span class="mf">1.</span>
        <span class="k">return</span> <span class="n">score</span></div>

<div class="viewcode-block" id="SortedDict.changeKeysCase"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.changeKeysCase">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">changeKeysCase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Change all the keys in the dictionary to be upper/lower case</span>

<span class="sd">        :param case: &#39;upper&#39; or &#39;lower&#39;</span>

<span class="sd">        :param recursive: apply this recursively</span>

<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">case</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">case</span><span class="o">==</span><span class="s1">&#39;upper&#39;</span> <span class="ow">or</span> <span class="n">case</span><span class="o">==</span><span class="s1">&#39;lower&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">kid</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">tmp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">kid</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">case</span><span class="o">==</span><span class="s1">&#39;upper&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span><span class="o">=</span><span class="n">tmp</span>
                <span class="k">elif</span> <span class="n">case</span><span class="o">==</span><span class="s1">&#39;lower&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span><span class="o">=</span><span class="n">tmp</span>
            <span class="k">for</span> <span class="n">kid</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">recursive</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">],</span><span class="n">SortedDict</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">]</span><span class="o">.</span><span class="n">changeKeysCase</span><span class="p">(</span><span class="n">case</span><span class="p">,</span><span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="SortedDict.traverse"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.traverse">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">onlyDict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">onlyLeaf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skipDynaLoad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Equivalent to the `tree` command in UNIX</span>

<span class="sd">        :param string: prepend this string</span>

<span class="sd">        :param level: depth</span>

<span class="sd">        :param onlyDict: only subtrees and not the leafs</span>

<span class="sd">        :return: list of strings containing the dictionary path to each object</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">string</span><span class="p">,</span><span class="n">level</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">onlyDict</span><span class="o">=</span><span class="n">onlyDict</span><span class="p">,</span> <span class="n">onlyLeaf</span><span class="o">=</span><span class="n">onlyLeaf</span><span class="p">,</span> <span class="n">skipDynaLoad</span><span class="o">=</span><span class="n">skipDynaLoad</span><span class="p">)</span></div>

<div class="viewcode-block" id="SortedDict.walk"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.walk">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">walk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Walk every member and call a function on the keyword and value</span>

<span class="sd">        :param function: `function(self,kid,**kw)`</span>

<span class="sd">        :param \**kw: kw passed to the function</span>

<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">kid</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">],</span><span class="s1">&#39;walk&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">]</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">function</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">kid</span><span class="p">]</span><span class="o">=</span><span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">kid</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="SortedDict.safe_del"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.safe_del">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">safe_del</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Delete key entry only if it is present</span>

<span class="sd">        :param key: key to be deleted</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

<div class="viewcode-block" id="SortedDict.flatten"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.flatten">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The hierarchical structure of the dictionaries is flattened</span>

<span class="sd">        :return: SortedDict populated with the flattened content of the dictionary</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">tmp</span><span class="o">=</span><span class="n">SortedDict</span><span class="p">(</span><span class="n">caseInsensitive</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">caseInsensitive</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">],</span><span class="n">SortedDict</span><span class="p">):</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tmp</span></div>

<div class="viewcode-block" id="SortedDict.setFlat"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.setFlat">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">setFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        recursively searches dictionary for key in order to set a value</span>
<span class="sd">        raises KeyError if key could not be found, so this method cannot</span>
<span class="sd">        be used to set new entries in the dictionary</span>

<span class="sd">        :param key: key to be set</span>

<span class="sd">        :param value: value to set</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">value</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">],</span><span class="n">SortedDict</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">setFlat</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;`</span><span class="si">%s</span><span class="s1">` could not be found throughout the dictionary&#39;</span><span class="o">%</span><span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="SortedDict.check_location"><a class="viewcode-back" href="../../api/coilpy.sortedDict.html#coilpy.sortedDict.SortedDict.check_location">[docs]</a>    <span class="nd">@dynaLoad</span>
    <span class="k">def</span> <span class="nf">check_location</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">_special1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        check if location exist and equals value (if value is specified)</span>

<span class="sd">        :param location: location as string</span>

<span class="sd">        :param value: value for which to return equal</span>

<span class="sd">        :return: True/False</span>

<span class="sd">        &gt;&gt; root[&#39;SETTINGS&#39;].check_location(&quot;[&#39;EXPERIMENT&#39;][&#39;shot&#39;]&quot;, 133221)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="o">+</span><span class="n">location</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_special1</span> <span class="ow">and</span> <span class="n">evalExpr</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="o">+</span><span class="n">location</span><span class="p">))</span><span class="o">!=</span><span class="n">evalExpr</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="nf">__popup_menu__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Dummy method to avoid dynamic loading for classes that do not override it</span>

<span class="sd">        :return: empty list</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<span class="c1">#automatic handle removing of _OMFITxxx attributes when pickling</span>
<span class="n">_dumps</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">aa</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">({</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;yo&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">})</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">({</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;yo&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;dd&#39;</span><span class="p">:</span> <span class="n">aa</span><span class="p">})</span>
    <span class="n">bb</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">({</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;foobar&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;yo&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">})</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">({</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;foobar&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;yo&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;dd&#39;</span><span class="p">:</span> <span class="n">bb</span><span class="p">})</span>
    <span class="n">diff</span><span class="p">,</span> <span class="n">switch</span><span class="p">,</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
</pre></div>

              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2020, Caoxiang Zhu.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.0.2.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>