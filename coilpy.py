#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
coilpy is a python library for plasma physics and coil designing.
Mainly for FOCUS related data virtualization.
Written by CaoXiang ZHU (czhu@pppl.gov)

Table of contents:
1. read plasma boundary (FOCUS format);
2. plot the plasma surface (several types plotting);
3. read the poincare plot data generated by GLASS;
4. get the data from a sequence FOCUS run;
5. read coils.xxx file;
6. tansform spline2xyz format data into a coils file;
7. plot the coils;
8. produce an array of color rgb float triplets;
9. expand single coil filament to a rectangle coil;
10. plot plasma surface from VMEC cdf format output file;
11. poincare plotting from OCULUS data;
12. plot coils from FOCUS hdf5 output data;
13. animating the coils evolution from FOCUS hdf5 output data;
14. plot cost function converging curves from FOCUS hdf5 output data;
15. plot plasma and/or Bn shape in hdf5 file;
16. read *.focus file and store a coil object;
17. write coil/focus object data to an external file;
18. map coils in multiple periods;
19. apply coil perturbation in Fourier space;
20. calculate surface normal for a given toroidal surface;
21. convert Fourier coefficients into discritized coils in xyz;
22. read vmec input/output and prepare FOCUS input plasma boundary;
23. plot the hdf5 file from FIELDLINES;
24. compare the variables in two datasets, data1 and data2;
25. calculate the magnetic field at a position in a mgrid file;
26. plot the target/realized Bn distribution on the theta-zeta plane;
27. plot the winding surface;
28. write down coils on a winding surface

'''


#QT_API imcompactible
# only valid for PPPL

'''
import sip
API_NAMES = ["QDate", "QDateTime", "QString", "QTextStream", "QTime", "QUrl", "QVariant"]
API_VERSION = 2
for name in API_NAMES:
    sip.setapi(name, API_VERSION)
from PyQt4.QtCore import *
from PyQt4.QtGui import *
from PyQt4.QtSvg import *
from PyQt4.QtCore import pyqtSignal as Signal
from PyQt4.QtCore import pyqtSlot as Slot
'''
from mayavi import mlab
import numpy as np
import matplotlib.pyplot as plt
import xarray as ncdata
from mpl_toolkits.mplot3d import Axes3D
import os.path
from matplotlib import cm
import h5py
from mayavi import mlab # to overrid plt.mlab
import colorsys
from scipy import optimize
import subprocess
import f90nml
import keyword
from scipy.io import netcdf
from scipy.interpolate import interp1d
from pyevtk.hl import gridToVTK, pointsToVTK
import pandas as pd
import sys

import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

#------------------------------------------
class coil(object):
    '''
    coil class
    '''
    name = 'default_name'
    I = 0.0
    group = 1
    def __init__(self):
        self.x = []
        self.y = []
        self.z = []
    def __del__(self):
        class_name = self.__class__.__name__
        #print class_name, "destroyed" 
    def interpolate(self, num=256):
        cur_len = len(self.x)
        assert cur_len > 0
        theta = np.linspace(0, 1, num=cur_len, endpoint=True)
        theta_new = np.linspace(0, 1, num=num, endpoint=True)
        for xyz in [self.x, self.y, self.z]:
            f = interp1d(theta, xyz, kind='cubic')
            xyz[:] = f(theta_new)
        return
    def expand(self, ratio):
        """
        expand coil with a ratio
        """
        # number of points
        nseg = len(self.x)
        # assuming closed curve; should be revised
        if True: #abs(self.x[0] - self.x[-1]) < 1.0E-8:
            nseg -= 1
        assert nseg>1
        # get centroid
        centroid = np.array([np.sum(self.x[0:nseg])/nseg, 
                             np.sum(self.y[0:nseg])/nseg,
                             np.sum(self.z[0:nseg])/nseg])
        # expand
        for i in range(nseg):
            xyz = np.array([self.x[i], self.y[i], self.z[i]])
            dr = xyz-centroid
            [self.x[i], self.y[i], self.z[i]] = centroid + ratio*dr
        try:
            self.x[nseg] = self.x[0]
            self.y[nseg] = self.y[0]
            self.z[nseg] = self.z[0]
            return
        except:
            return

#------------------------------------------
class hdf5(object):
    '''
    load hdf5 results
    '''
    def __init__(self, hdf5file):
        self.filename = hdf5file
        try:
            hdf5 = h5py.File(self.filename, 'r')
            self.names = hdf5.keys()
            for name in self.names:
                if name in keyword.kwlist: # avoid assign keywords
                    setattr(self, name+'1', hdf5[name][()])
                else:
                    setattr(self, name, hdf5[name][()])
                if hdf5[name][()].dtype == 'S1': #only for hdf5 string;
                    setattr(self, name, ''.join(hdf5[name][()]))
        except IOError:
            print "Error: this is not a valid hdf5 file."
        else:
            print "Read ", len(self.names), " objects in", hdf5
            if hasattr(self, 'version') :
                print "FOCUS version :", self.version
            hdf5.close()
    def __del__(self):
        class_name = self.__class__.__name__
        #print class_name, "destroyed" 

#------------------------------------------
class fourier(object):
    '''
    fourier series class
    x = a0 + a1*cos(t) + a2*cos(2t) + ...+ b1*sin(t) + b2*sin(2t) + ..
    '''
    def __init__(self, FouData):
        assert len(FouData) > 0
        self.ndim = (len(FouData)+1)/2 - 1  #number of Fourier coefficients; 0,1,2,...,Ndim
        self.cos = np.zeros(self.ndim + 1)
        self.sin = np.zeros(self.ndim + 1)

        if len(FouData) == 2*self.ndim + 1: #omit b0
            self.cos[0:self.ndim+1] = FouData[0:self.ndim+1]
            self.sin[1:self.ndim+1] = FouData[self.ndim+1:2*self.ndim + 1]
        elif len(FouData) == 2*self.ndim + 2: #keep b0
            self.cos[0:self.ndim+1] = FouData[0:self.ndim+1]
            self.sin[0:self.ndim+1] = FouData[self.ndim+1:2*self.ndim + 2]
        else:
            print "Error: dimensions not matched. ", len(FouData)

    def disc(self, nseg=100, order=0): #discretize the data
        '''
        order = 0, 1, 2, 3
        '''
        assert self.ndim > 0
        assert nseg > 0
        assert order in [0,1,2,3]
        
        m = np.arange(self.ndim + 1)
        ang = np.linspace(0, 2*np.pi, nseg)
        x = np.zeros(nseg)
        if order == 0: 
            for ii in range(nseg):
                x[ii] = sum(self.cos*np.cos(m*ang[ii]) + self.sin*np.sin(m*ang[ii]))
        elif order == 1: 
            for ii in range(nseg):
                x[ii] = sum(-m*self.cos*np.sin(m*ang[ii]) + m*self.sin*np.cos(m*ang[ii]))    
        elif order == 2: 
            for ii in range(nseg):
                x[ii] = sum(-m*m*self.cos*np.cos(m*ang[ii]) - m*m*self.sin*np.sin(m*ang[ii]))  
        elif order == 3: 
            for ii in range(nseg):
                x[ii] = sum(m*m*m*self.cos*np.sin(m*ang[ii]) - m*m*m*self.sin*np.cos(m*ang[ii]))  
        else:
            raise ValueError("No such option!")
        return x

    def evaluate(self, t, *args):
        m = np.arange(self.ndim + 1)
        return sum(self.cos * np.cos(m*t) + self.sin * np.sin(m*t))

    def __del__(self):
        class_name = self.__class__.__name__
        #print class_name, "destroyed" 

#------------------------------------------
class focus(object):
    '''
    class for focus coil mainly containing coil parameters
    '''
    def __init__(self, itype, Npara):
        self.itype = itype
        self.name   = 'coil1'
        self.NS     = 128
        self.I      = 1.0E6
        self.Ic     = 1
        self.L      = 1.0
        self.Lc     = 1
        self.Lc     = 1.0
        if self.itype == 1 :
            self.NF = Npara
            assert self.NF >= 1
            self.xc = np.zeros(self.NF + 1)
            self.xs = np.zeros(self.NF + 1)
            self.yc = np.zeros(self.NF + 1)
            self.ys = np.zeros(self.NF + 1)
            self.zc = np.zeros(self.NF + 1)
            self.zs = np.zeros(self.NF + 1)
    def __del__(self):
        class_name = self.__class__.__name__
        #print class_name, "destroyed" 

#------------------------------------------
class fourier_surface(object):
    '''
    surface in Fourier representation
    R = \sum RBC cos(mu-nv) + RBS sin(mu-nv)
    Z = \sum ZBC cos(mu-nv) + ZBS sin(mu-nv)
    '''
    def __init__(self, mnmodes=999):
        # initialization
        self.mn = mnmodes # total number of harmonics
        assert self.mn > 0
        self.xm  = np.zeros(self.mn)
        self.xn  = np.zeros(self.mn)
        self.rbc = np.zeros(self.mn)
        self.rbs = np.zeros(self.mn)
        self.zbc = np.zeros(self.mn)
        self.zbs = np.zeros(self.mn)

    def disc_rz(self, zeta=0.0, npoints=360): 
        # discretization in (R,Z) at phi=zeta
        assert npoints > 0
        self.rr = np.zeros(npoints)
        self.zz = np.zeros(npoints)
        theta = np.linspace(0, 2*np.pi, npoints)
        for ipoint in range(npoints):
            tmpr = self.rbc * np.cos(self.xm*theta[ipoint]-self.xn*zeta) \
                 + self.rbs * np.sin(self.xm*theta[ipoint]-self.xn*zeta) 
            self.rr[ipoint] = np.sum(tmpr) #r value at ipont

            tmpz = self.zbc * np.cos(self.xm*theta[ipoint]-self.xn*zeta) \
                 + self.zbs * np.sin(self.xm*theta[ipoint]-self.xn*zeta) 
            self.zz[ipoint] = np.sum(tmpz) #z value at ipont

    def disc_xyz(self, zeta=0.0, zeta1=np.pi*2, npol=360, ntor=360):
        # discretization in (X,Y,Z) between phi=zeta and phi=zeta1
        assert npol > 0 and ntor > 0
        self.xsurf  = np.zeros([npol, ntor]) # xsurf surface elements
        self.ysurf  = np.zeros([npol, ntor])
        self.zsurf  = np.zeros([npol, ntor])
        for i in range(ntor):
            ator = zeta + i*(zeta1-zeta)/(ntor-1) #zeta
            self.disc_rz(zeta=ator, npoints=npol)
            self.xsurf[:,i] = self.rr * np.cos(ator)
            self.ysurf[:,i] = self.rr * np.sin(ator)
            self.zsurf[:,i] = self.zz

    def plot(self, zeta=0.0, npoints=360, color=(1,0,0), style='-', width=2.0,
             label='toroidal surface', marker=None):
        if plt.get_fignums():
            fig = plt.gcf()
            ax = plt.gca()
        else :
            fig, ax = plt.subplots()
        self.disc_rz(zeta=zeta, npoints=npoints)
        ax.plot(self.rr, self.zz, color=color, linewidth=width, linestyle=style, label=label, marker=marker)
        plt.axis('equal')
        plt.xlabel('R [m]',fontsize=20)
        plt.ylabel('Z [m]',fontsize=20)
        plt.xticks(fontsize=16)
        plt.yticks(fontsize=16)

    def __del__(self):
        class_name = self.__class__.__name__
        

#------------------------------------------  1  ----------------------------------------------------
def read_plasma_boundary(filename):
    '''
    The function read plasma.boundary file in FOCUS format and return
    a structured np.array with [n, m, Rbc, Rbs, Zbc, Zbs]
    '''
    with open(filename, 'r') as f:
        line = f.readline() #skip one line
        line = f.readline()
        num = int(line.split()[0]) #harmonics number
        nfp = int(line.split()[1]) #number of field periodicity
        nbn = int(line.split()[2]) #number of Bn harmonics
        plas_data = np.zeros(num, dtype=[('n', np.float64),('m',np.float64), #m,n saving as double
                                         ('Rbc',np.float64), ('Rbs', np.float64),
                                         ('Zbc',np.float64), ('Zbs', np.float64)])
        line = f.readline() #skip one line
        line = f.readline() #skip one line
        for i in range(num):
            line = f.readline()
            plas_data[i] = tuple([float(j) for j in line.split()])
        plas_data['n'] *= nfp

        if nbn>0 :
            bn_data = np.zeros(nbn, dtype=[('n', np.float64),('m',np.float64),
                                           ('bnc', np.float64),('bns',np.float64)])
            line = f.readline() #skip one line
            line = f.readline() #skip one line
            for i in range(nbn):
                line = f.readline()
                bn_data[i] = tuple([float(j) for j in line.split()])
            bn_data['n'] *= nfp
        else :
            bn_data = []        
    print "read {} Fourier harmonics for plasma boundary and {} for Bn distribution in {}."\
        .format(num,nbn,filename)
    return plas_data, bn_data
        
#------------------------------------------  2  ----------------------------------------------------
def plot_plasma_boundary(filename,plottype='cross-section',zeta=0.0, zeta1=2*np.pi, colormap='coolwarm',
                         color=(1,0,0),style='-',width=2.0,lbl='Target boundary',npol=128,ntor=128, 
                         marker=None, npoints=360, location=False, show_figure=True):
    '''
    plot the plasma boundary;
    plottype:
            cross-section -> 2D plot at zeta plane
            surface       -> 3D surface using matplotlib
            surface3d     -> 3D surface using mayavi
            bnormal       -> 3D surface plot with Bn scalar using mayavi
    '''
    plas, bfou = read_plasma_boundary(filename)
    half = 0.0
    maxR, minR, maxZ, minZ = 0.0, 999.0, 0.0, 999.0
    if plottype=='cross-section' : #plot cross-section
         #number of points
        theta = np.linspace(0,2*np.pi, npoints)
        r = np.zeros(npoints)
        z = np.zeros(npoints)
        for ipoint in range(npoints):
            tmpr = plas['Rbc']*np.cos(plas['m']*theta[ipoint]-plas['n']*zeta) + \
                   plas['Rbs']*np.sin(plas['m']*theta[ipoint]-plas['n']*zeta)
            r[ipoint] = np.sum(tmpr) #r value at ipont
            maxR = max(np.sum(tmpr), maxR)
            minR = min(np.sum(tmpr), minR)

            tmpz = plas['Zbc']*np.cos(plas['m']*theta[ipoint]-plas['n']*zeta) + \
                   plas['Zbs']*np.sin(plas['m']*theta[ipoint]-plas['n']*zeta)
            z[ipoint] = np.sum(tmpz) #z value at ipont
            maxZ = max(np.sum(tmpz), maxZ)
            minZ = min(np.sum(tmpz), minZ)
        if not show_figure:
            return r, z
        if plt.get_fignums():
            fig = plt.gcf()
            ax = plt.gca()
        else :
            fig, ax = plt.subplots()
        ax.plot(r, z, color=color,linewidth=width,linestyle=style,label=lbl, marker=marker)
        # add angle notation
        if location:
            for ang in [0, np.pi/2]:
                tmpr = plas['Rbc']*np.cos(plas['m']*ang-plas['n']*zeta) + \
                    plas['Rbs']*np.sin(plas['m']*ang-plas['n']*zeta)
                tmpr = np.sum(tmpr) #r value at ipont
                tmpz = plas['Zbc']*np.cos(plas['m']*ang-plas['n']*zeta) + \
                    plas['Zbs']*np.sin(plas['m']*ang-plas['n']*zeta)
                tmpz = np.sum(tmpz) #z value at ipont
                ax.text(tmpr, tmpz, '{:} pi'.format(ang/np.pi), color=color)
        plt.axis('equal')
        plt.xlabel('R [m]',fontsize=20)
        plt.ylabel('Z [m]',fontsize=20)
        plt.xticks(fontsize=16)
        plt.yticks(fontsize=16)
        plt.tight_layout()
        return maxR, minR, maxZ, minZ
        #p1 = [x[npol/2  ,ntor/2  ], y[npol/2  ,ntor/2  ], z[npol/2  ,ntor/2  ]]
        #p2 = [x[npol/2+1,ntor/2  ], y[npol/2+1,ntor/2  ], z[npol/2+1,ntor/2  ]]
        #p3 = [x[npol/2  ,ntor/2+1], y[npol/2  ,ntor/2+1], z[npol/2  ,ntor/2+1]]
        #p4 = [x[npol/2+1,ntor/2+1], y[npol/2+1,ntor/2+1], z[npol/2+1,ntor/2+1]]
        return maxR, minR, maxZ, minZ
    elif plottype == 'surface3d' or plottype == 'surface' :
        x=np.zeros((npol+1,ntor+1))
        y=np.zeros((npol+1,ntor+1))
        z=np.zeros((npol+1,ntor+1))

        for i in range(ntor+1):
            ator = zeta + (i+half)*(zeta1-zeta)/ntor #zeta
            for j in range(npol+1):
                apol = (j+half)*2*np.pi/npol #theta
                tmpr = plas['Rbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Rbs']*np.sin(plas['m']*apol-plas['n']*ator)
                tmpz = plas['Zbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Zbs']*np.sin(plas['m']*apol-plas['n']*ator)
                maxR = max(np.sum(tmpr), maxR)
                minR = min(np.sum(tmpr), minR)
                maxZ = max(np.sum(tmpz), maxZ)
                minZ = min(np.sum(tmpz), minZ)
                x[j,i] = np.sum(tmpr) * np.cos(ator)
                y[j,i] = np.sum(tmpr) * np.sin(ator)
                z[j,i] = np.sum(tmpz)  
        if not show_figure:
            return x, y, z    
        if plottype == 'surface' : #plot surface
            if plt.get_fignums():
                fig = plt.gcf()
            else :
                fig = plt.figure()
            ax = fig.gca(projection='3d')
            ax.plot_surface(x,y,z,color='white')  
        else:
        #fig = mlab.figure(bgcolor=(1,1,1),fgcolor=(0,0,0),size=(600,600))
            surf = mlab.mesh(x,y,z,color=color, representation = 'surface')
        # Change the visualization parameters.
        #surf.actor.property.interpolation = 'phong'
        #surf.actor.property.specular = 01.0
        #surf.actor.property.specular_power = 100
        #surf.scene.light_manager.light_mode = "vtk"
        return
    elif plottype == 'bnormal' :
        x=np.zeros((npol+1,ntor+1))
        y=np.zeros((npol+1,ntor+1))
        z=np.zeros((npol+1,ntor+1))
        targetBn = np.zeros((npol+1,ntor+1))

        for i in range(ntor+1):
            ator = zeta + (i+half)*(zeta1-zeta)/ntor #zeta
            for j in range(npol+1):
                apol = (j+half)*2*np.pi/npol #theta
                tmpr = plas['Rbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Rbs']*np.sin(plas['m']*apol-plas['n']*ator)
                tmpz = plas['Zbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Zbs']*np.sin(plas['m']*apol-plas['n']*ator)
                tmpb = bfou['bnc']*np.cos(bfou['m']*apol-bfou['n']*ator) + \
                       bfou['bns']*np.sin(bfou['m']*apol-bfou['n']*ator)
                x[j,i] = np.sum(tmpr) * np.cos(ator)
                y[j,i] = np.sum(tmpr) * np.sin(ator)
                z[j,i] = np.sum(tmpz)
                targetBn[j,i] = np.sum(tmpb)
        if not show_figure:
            return targetBn
        #fig = mlab.figure(bgcolor=(1,1,1),fgcolor=(0,0,0),size=(600,600))
        mlab.mesh(x,y,z,scalars=targetBn, colormap=colormap)
        return 
    else :
        raise NameError("No such option!")
        print "plottype = cross-section/surface/surface3d/bnormal"
        

#------------------------------------------  3  ----------------------------------------------------
def read_ppfile(ppfile):
    '''
    INPUT : ppfile (string, the poincare plot (pp) binary file path and name)
    OUTPUT: R, Z (list, the two lists represent the data in R and Z)
    DETAIL: This function read a pp file and return the data in two lists, used for GGLASS/FOCUS
            pp file. (The two have slightly differences at the header.)
    '''
    r = np.array([])
    z = np.array([])
    with open(ppfile, 'rb') as f:
        while True:
            head = np.fromfile(f, dtype=np.int32, count=1) #fortran unformatted header
            #detect end of file
            if not head:
                break
            length = head[0]
            #print(length)
            npoints = np.fromfile(f, dtype=np.int32, count=length/4)[0] #length/4 = no. of integers
            #print(npoints)
            nonuse = f.read(8)
            rzdata = np.fromfile(f, dtype=np.float64, count=2*(1+npoints)) #reading all the R,Z data
            #print(len(rzdata))
            rzdata = rzdata.reshape(1+npoints,2)
            r = np.append(r, rzdata[:,0])
            z = np.append(z, rzdata[:,1])
            nouse = f.read(4)  #skip write ender
    return r, z
 
#------------------------------------------  3  ----------------------------------------------------
def sequence_h5_data(prefix, variable, result, istart, istop, istep, itype):
    '''
    INPUT : prefix   (string, the path and prefix, like'./seq.NC')
          : variable (string, the variable name that is varying, like 'Ncoils')
          : result   (string, the result term that want to be plotted, like 'Bnorm')
          : istart   (int   , starting number)
          : istop    (int   , stopping number)
          : istep    (int   , stepp size)
          : ityp     (strung, either "times" or "plus", selecting different loop type)
    OUTPUT: rslt     (list/np.array, rslt[i] = [tau, bnorm])
    DETAIL: This function reads the result data in mulptiple files, used for FOCUS sequence running
    '''
    suffix = '.fo.h5'
    #get number of files and generating looped names
    if itype == 'times':
        N=istop-istart+1
        numbers = [istep**exp for exp in range(istart, istop)]
        numbers.insert(0,0)
    elif itype == 'plus':
        N=(istop-istart)/istep + 1
        numbers = range(istart, istop + istep, istep)
    else:
        raise NameError("Either 'plus' or 'times'")
    filename = [prefix + '=+' + str(x).zfill(6) + suffix for x in numbers]

    rslt = [] #empty list

    for iname in filename:
        with h5py.File(iname,'r') as h5_fid:
            evolution = h5_fid['evolution'].value
            marker = str(h5_fid[variable].value[0])
            tau = evolution[0,:]
            energy = evolution[1,:]
            deriv = evolution[2,:]
            bnorm = evolution[3,:]
            tflux = evolution[4,:]
            ttlen = evolution[5,:]
            rslt.append([tau,bnorm])  #append[tau, bnorm]; will be changed later
    return rslt
#------------------------------------------  4  ----------------------------------------------------
    
def read_coils(filename, filetype='coils'):
    '''
    filename : the path for the coils file
    return an array of coil class;
    '''

    if not os.path.exists(filename) :
        raise IOError ("File not existed. Please check again!")

    Ncoils = 0

    if filetype == 'coils':  # traditional coils.xxx file
        with open(filename,'r') as coilfile: #get each coil segments number
            coilfile.readline()
            coilfile.readline()
            coilfile.readline()
            for line in coilfile:
                if line[0:2] == 'end':
                    break

                if len(line.split()) > 4 :
                    Ncoils = Ncoils + 1
                    continue
        print "Read {} coils in {}.".format(Ncoils, filename)
        coildata = np.ndarray((Ncoils,),dtype=np.object)
        with open(filename,'r') as coilfile: #read coil xyz and I
            coilfile.readline()
            coilfile.readline()
            coilfile.readline()
            icoil = 0
            coildata[0] = coil()
            for line in coilfile:
                linelist = line.split()
                if len(linelist) < 4 :
                    print"End of file or invalid format!"
                    break
                coildata[icoil].x.append(float(linelist[0]))
                coildata[icoil].y.append(float(linelist[1]))
                coildata[icoil].z.append(float(linelist[2]))
                if len(linelist) == 4 :
                    coildata[icoil].I = float(linelist[-1])
                if len(linelist) > 4 :
                    coildata[icoil].name = linelist[-1]
                    #print "get one new coil"
                    icoil = icoil + 1
                    if icoil >= Ncoils :
                        break
                    coildata[icoil] = coil()
                    continue
            if icoil != Ncoils:
                raise ValueError("The number of coils doesn't match!")
    elif filetype == 'focus': # FOCUS format file with Fourier representation
        with open(filename, 'r') as coilfile:
            coilfile.readline()
            Ncoils = int(coilfile.readline())
            #print "Read {} coils.".format(Ncoils)
            coildata = np.ndarray((Ncoils,),dtype=np.object)

            for icoil in range(Ncoils):
                coildata[icoil] = coil()
                coilfile.readline()
                coilfile.readline()

                linelist = coilfile.readline().split()
                coildata[icoil].name = linelist[-1]     # coil name
                coilfile.readline()
                linelist = coilfile.readline().split()
                Nseg = int(linelist[0])+1               # coil No. of segments; extra one for closed curves
                coildata[icoil].I = float(linelist[1])  # coil current
                coilfile.readline()
                NFcoil = int(coilfile.readline())       # No. of Fourier harmonics
                             
                coilfile.readline()
                strlist = coilfile.readline().split() + coilfile.readline().split() # x cos & sin harmonics
                FouData = [float(i) for i in strlist]
                coildata[icoil].x =  fourier(FouData).disc(Nseg) # discretize x
                strlist = coilfile.readline().split() + coilfile.readline().split() # y cos & sin harmonics
                FouData = [float(i) for i in strlist]
                coildata[icoil].y = fourier(FouData).disc(Nseg) # discretize y
                strlist = coilfile.readline().split() + coilfile.readline().split() # z cos & sin harmonics
                FouData = [float(i) for i in strlist]
                coildata[icoil].z = fourier(FouData).disc(Nseg) # discretize z
        
    return(coildata)

#------------------------------------------  5  ----------------------------------------------------
def xyz2coils(xyzname,coilsname):
    '''
    This function read sxyz.dat produced by spline2xyz and then write into a coils file
    INPUT  : xyzname  (string, filename for xyzdata)
    OUTPUT : coilsname(string, filename for coils file)
    '''
    x = []
    y = []
    z = []
    c = []
    n = []
    with open(xyzname, 'r') as xyzfile:
        for line in xyzfile:
            tmp=line.split()
            x.append(float(tmp[0]))
            y.append(float(tmp[1]))
            z.append(float(tmp[2]))
            c.append(float(tmp[3]))
            n.append(int (tmp[-1]))
    num = len(x)
    data = np.zeros(num, dtype=[('xyzc',np.float64,(1,4)), ('n',np.int)])
    for i in range(num):
        data[i] = ([x[i],y[i],z[i],1.0E7], n[i])
    coilnum = set(data['n'])

    with open(coilsname,'w') as coilsfile:
        coilsfile.write('periods 1'+'\n')
        coilsfile.write('begin filament'+'\n')
        coilsfile.write('mirror NUL'+'\n')
        for icoil in coilnum:
            a = data['xyzc'][data['n']==icoil]
            a[-1,-1,-1] = 0.0
            for ixyzc in a[:-2]:
                coilsfile.write(" ".join(map(str,ixyzc[0]))+'\n')
            coilsfile.write(" ".join(map(str,a[-1][0]))+'\t'+str(icoil)+'\t'+'Modular' +'\n')
        coilsfile.write('end'+'\n')
    print('Finish')

#------------------------------------------  6  ----------------------------------------------------
def plotBn(h5name, bntype='current'):
    '''
    This function is used for ploting the B normal distribution on the plasma surface calculated by
    FOCUS.
    INPUT : h5name(the hdf5 file name)
            bntype(target: plot tgtBn; current: plot curBn)
    OUTPUT: mlab figures
    '''
    with h5py.File(h5name, 'r') as h5file:
        x = h5file['xsurf'].value
        y = h5file['ysurf'].value
        z = h5file['zsurf'].value
        targetBn = h5file['tgtBn'].value
        currentBn = h5file['curBn'].value
    fig = mlab.figure(bgcolor=(1,1,1),fgcolor=(0,0,0),size=(600,600))
    if bntype == 'target':
        mesh = mlab.mesh(x,y,z,scalars=targetBn, colormap='RdBu')
    else:
        mesh = mlab.mesh(x,y,z,scalars=currentBn, colormap='RdBu')

#------------------------------------------  7  ----------------------------------------------------
def plot_coils(coil_data, plottype='filament', color=(0,0,1), width=2.0, recW=0.1, recH=0.1, \
                    opacity=1.0, WindSurf=None, EageOn=False, currents=False, tol=1E-3):
    '''
    This function plots out 3D coils in filename(coils file).
    It calls readcoil() to read coil and plot the data in mayave.
    INPUT :
            filename : coils file
            plottype : plot type (filament or real)
            color    : the single color tripet float; default blue;
            Ncolor   : number of colors used for coils (usually equals the number of coil categories)
    OUTPUT: 
            mlab figures (in current figure, otherwise in new figure)
    '''
    coil_data = np.atleast_1d(coil_data)
    Ncoils = len(coil_data)
    cur_array = np.array([icoil.I for icoil in coil_data])
    maxI = np.max(abs(cur_array))

    colors = []
    for i in range(Ncoils):
        if currents:
            colors.append(cm.bwr(int(128+coil_data[i].I/maxI*128))[0:3])
        else:
            colors.append(color) # identical colors for coils
    # plot coil currents
    ind = 1 + np.arange(0, Ncoils, 5, dtype=int)
    names = [coil_data[i-1].name for i in ind]
    if currents:
        fig = plt.figure()
        for i in range(Ncoils):
            if coil_data[i].I >= 0.0:
                plt.bar(i+1, coil_data[i].I, color='r', align='center')
            else:
                plt.bar(i+1, coil_data[i].I, color='b', align='center')
        plt.xlabel('coil label',fontsize=16)
        plt.ylabel('currents [A]',fontsize=16)
        plt.xticks(ind, names, fontsize=16)
        plt.yticks(fontsize=16)
        #plt.tight_layout()

    if plottype == 'filament' :
        for i in range(Ncoils):
            mlab.plot3d(coil_data[i].x, coil_data[i].y, coil_data[i].z, color = colors[i], line_width=width, opacity=opacity)
    elif plottype == 'real' :
        for i in range(Ncoils):
            xsurf, ysurf, zsurf, ss = expand(coil_data[i].x, coil_data[i].y, coil_data[i].z, recW, recH, WindSurf, tol=tol)
            mlab.mesh(xsurf, ysurf, zsurf, color=colors[i], opacity=opacity)
            if EageOn :
                for ii in range(4):
                    mlab.plot3d(xsurf[ii,:], ysurf[ii,:], zsurf[ii,:], color=(0,0,0), line_width=width, opacity=opacity)

    return

#------------------------------------------  8  ----------------------------------------------------
def color_array( N ):
    '''
    This will return a list of N rgb float triplets from colorsysp.
    '''

    if N < 1 :
        raise ValueError("Please provide a positive integer!")
    return [colorsys.hsv_to_rgb((i+1.0)/3.0, 1.0, 1.0) for i in np.linspace(0.0, 1.0, N)]
    #return [(0.0, i, 1-i) for i in np.linspace(0.0, 1.0, N)]

#------------------------------------------  9  ----------------------------------------------------
def expand(x, y, z, b, h, scalar=None, WindSurf=None, tol=1E-3):
    '''
    This function expand single coil filament to a rectangle coil;
    x, y, z : array of the coil filament;
    b : width
    h : height
    WindSurf : winding surface data;
    tol: root find tolarence
    '''
    n = np.size(x)
    t = np.linspace(0, 2*np.pi, n)
    dt = 2*np.pi/(n-1)

    xt = np.gradient(x)/dt
    yt = np.gradient(y)/dt
    zt = np.gradient(z)/dt
    tt = np.sqrt(xt*xt + yt*yt + zt*zt)
    xt = xt/tt
    yt = yt/tt
    zt = zt/tt
    '''
    xa = np.gradient(xt)/dt
    ya = np.gradient(yt)/dt
    za = np.gradient(zt)/dt

    aa = np.sqrt(xa*xa + ya*ya + za*za)
    '''
    center_x = np.average(x[0:n-1])
    center_y = np.average(y[0:n-1])
    center_z = np.average(z[0:n-1])

    # use surface normal if needed
    if WindSurf is not None:
        xn = np.zeros(n)
        yn = np.zeros(n)
        zn = np.zeros(n)
        for i in range(n):
            xn[i], yn[i], zn[i] = surfnorm(x[i], y[i], z[i], WindSurf, tol=tol)
    else:
        xn = x - center_x
        yn = y - center_y
        zn = z - center_z
        nn = np.sqrt(xn*xn + yn*yn + zn*zn)
        xn = xn/nn
        yn = yn/nn
        zn = zn/nn
   
    xb = yt*zn - yn*zt
    yb = zt*xn - zn*xt
    zb = xt*yn - xn*yt
    bb = np.sqrt(xb*xb + yb*yb + zb*zb)
    xb = xb/bb
    yb = yb/bb
    zb = zb/bb

    x1 = x - b/2*xb + h/2*xn
    y1 = y - b/2*yb + h/2*yn
    z1 = z - b/2*zb + h/2*zn

    x2 = x + b/2*xb + h/2*xn
    y2 = y + b/2*yb + h/2*yn
    z2 = z + b/2*zb + h/2*zn

    x3 = x + b/2*xb - h/2*xn
    y3 = y + b/2*yb - h/2*yn
    z3 = z + b/2*zb - h/2*zn

    x4 = x - b/2*xb - h/2*xn
    y4 = y - b/2*yb - h/2*yn
    z4 = z - b/2*zb - h/2*zn

    xx = np.array([x1, x2, x3, x4, x1])
    yy = np.array([y1, y2, y3, y4, y1])
    zz = np.array([z1, z2, z3, z4, z1])

    if scalar is None:
        ss = None
    else :
        ss = np.array([scalar, scalar, scalar, scalar, scalar])

    return xx, yy, zz, ss

#------------------------------------------  10  ----------------------------------------------------
#this can be consistent with plot_plasma-boundary
def plot_vmec_surface(wout, ns=-1, plottype='cross-section',zeta=0.0, zeta1=2*np.pi,
                         color=(1,0,0),style='-', marker=None, width=2.0, lbl='VMEC_surface',npol=128,ntor=128, prange='full'):
    '''
    wout : the vmec netcdf file;
    plot the ns-th flux surface;
    '''
    half = 0.5
    vmec = ncdata.open_dataset(wout)
    mf = vmec['mpol'].values
    nf = vmec['ntor'].values
    xm = vmec['xm'].values
    xn = vmec['xn'].values
    rmnc = vmec['rmnc'].values
    zmns = vmec['zmns'].values
    rbc = rmnc[ns,:]
    zbs = zmns[ns,:]
    
    if vmec['lasym__logical__'].values: # if no stellarator symmetry
        zmnc = vmec['zmnc'].values
        rmns = vmec['rmns'].values
        rbs = rmns[ns,:]
        zbc = zmnc[ns,:]
    else :
        rbs = np.zeros(np.shape(rbc))
        zbc = np.zeros(np.shape(rbc))
    
    if plottype=='cross-section' : #plot cross-section
        npoints = 361 #number of points
        theta = np.linspace(0,2*np.pi, npoints)
        r = np.zeros(npoints)
        z = np.zeros(npoints)
        for ipoint in range(npoints):
            tmpr = rbc*np.cos(xm*theta[ipoint]-xn*zeta) + rbs*np.sin(xm*theta[ipoint]-xn*zeta)
            r[ipoint] = np.sum(tmpr) #r value at ipont

            tmpz = zbs*np.sin(xm*theta[ipoint]-xn*zeta) + zbc*np.cos(xm*theta[ipoint]-xn*zeta)
            z[ipoint] = np.sum(tmpz) #z value at ipont
        if plt.get_fignums():
            fig = plt.gcf()
            ax = plt.gca()
        else :
            fig, ax = plt.subplots()

        plt.axis('equal')
        plt.xlabel('R [m]',fontsize=20)
        plt.ylabel('Z [m]',fontsize=20)
        plt.xticks(fontsize=16)
        plt.yticks(fontsize=16)
        plt.tight_layout()

        if prange == 'full':
            ax.plot(r, z, color=color,linewidth=width,linestyle=style,label=lbl, marker=marker)
            return r, z
        elif prange == 'upper':
            ax.plot(r[0:npoints/2+1], z[0:npoints/2+1], color=color,linewidth=width,linestyle=style,label=lbl)
            return r[0:npoints/2+1], z[0:npoints/2+1]
        elif prange == 'below':
            ax.plot(r[npoints/2:npoints], z[npoints/2:npoints], color=color,linewidth=width,linestyle=style,label=lbl)
            return r[npoints/2:npoints], z[npoints/2:npoints]
        else:
            raise NameError("No such option!")
    #mayavi 3D plot
    elif plottype == 'surface3d' :
        x=np.zeros((npol+1,ntor+1))
        y=np.zeros((npol+1,ntor+1))
        z=np.zeros((npol+1,ntor+1))

        for i in range(ntor+1):
            ator = zeta + (i+half)*(zeta1-zeta)/ntor #zeta
            for j in range(npol+1):
                apol = (j+half)*2*np.pi/npol #theta
                tmpr = rbc*np.cos(xm*apol-xn*ator) 
                tmpz = zbs*np.sin(xm*apol-xn*ator)

                x[j,i] = np.sum(tmpr) * np.cos(ator)
                y[j,i] = np.sum(tmpr) * np.sin(ator)
                z[j,i] = np.sum(tmpz)                
        #fig = mlab.figure(bgcolor=(1,1,1),fgcolor=(0,0,0),size=(600,600))
        mlab.mesh(x,y,z,color=color)
        return x, y, z
    else :
        raise NameError("No such option!")
        print "plottype = cross-section/surface3d"

#------------------------------------------  10  ----------------------------------------------------
#this can be consistent with plot_plasma-boundary
def plot_vmec_iota(wout, plottype='flux',zeta=0.0,color='b',style='-', marker=None, width=2.0, lbl='VMEC_iota'):

    half = 0.5
    vmec = ncdata.open_dataset(wout)
    iota = vmec['iotaf'].values
    ns = vmec['ns'].values

    if plt.get_fignums():
        fig = plt.gcf()
        ax = plt.gca()
    else :
        fig, ax = plt.subplots()
    
    if plottype=='flux' : # plot flux
        sx = np.linspace(0, 1, ns, endpoint=True)
        plt.plot(sx, iota, color=color,linewidth=width,linestyle=style,label=lbl, marker=marker)
        plt.xlabel('s (normalized tor. flux)',fontsize=20)
        plt.ylabel(r'$\iota$',fontsize=20)
        plt.xticks(fontsize=16)
        plt.yticks(fontsize=16)
        return sx, iota

    elif plottype=='radial' : # plot radial
        xm = vmec['xm'].values
        xn = vmec['xn'].values
        rmnc = vmec['rmnc'].values
        zmns = vmec['zmns'].values
        rx = np.zeros_like(iota)

        if vmec['lasym__logical__'].values: # if no stellarator symmetry
            zmnc = vmec['zmnc'].values
            rmns = vmec['rmns'].values
        else :
            rmns = np.zeros_like(rmnc)
            zmnc = np.zeros_like(zmns)

        for i in range(ns):
            rbc = rmnc[i,:]
            zbs = zmns[i,:]
            rbs = rmns[i,:]
            zbc = zmnc[i,:]
            theta = 0.0
            tmpr = rbc*np.cos(xm*theta-xn*zeta) + rbs*np.sin(xm*theta-xn*zeta)
            rx[i] = np.sum(tmpr) #r value at ipont

        plt.plot(rx, iota, color=color,linewidth=width,linestyle=style,label=lbl, marker=marker)
        plt.xlabel('R [m]',fontsize=20)
        plt.ylabel(r'$\iota$',fontsize=20)
        plt.xticks(fontsize=16)
        plt.yticks(fontsize=16)
        return rx, iota

    else:
        raise NameError("No such option!")
    return

#------------------------------------------  11  ----------------------------------------------------
def plot_poincare( path, pp, code='Glass', prange='full', dotsize=0.5, marker='o', color='blue',
                   suffix = 'gl'):
    '''
    This function is for plotting Oculus style Poincare plots data.
    INPUT:
         path  -> directory path;
         pp    -> poincare plot data file name;
         code  -> code name, Glass or Focus;
         prange-> plot range, full, upper or lower;
    plot poincare in current figure;
    '''

    num = 0 #reset numberig
    suffix = 'gl' if code == 'Glass' else 'sp'
    nfill = 3
    ppfile = path + '.' + pp + '.' + suffix + '.P.' + str(num).zfill(nfill) + '.dat'
    # get current figure or build new one;
    if plt.get_fignums():
        fig = plt.gcf()
        ax = plt.gca()
    else :
        fig, ax = plt.subplots()
    # scattering data;      
    while os.path.isfile(ppfile):
        r,z = read_ppfile(ppfile)

        if prange == 'full':
            ax.scatter(r,z,dotsize,marker=marker,color=color)
        elif prange == 'upper':
            ax.scatter(r[z>=0.0],z[z>=0.0],dotsize,marker=marker,color=color)
        elif prange == 'lower':
            ax.scatter(r[z<=0.0],z[z<=0.0],dotsize,marker=marker,color=color)

        num += 1
        ppfile = path + '.' + pp + '.' + suffix + '.P.' + str(num).zfill(nfill) + '.dat'
    print "Poincare plots finished in ", path

#------------------------------------------  12  ----------------------------------------------------

def hdf5coil(h5data, nn = -1, old=False):
    '''
    read FOCUS hdf5 output file and return the nn-th coil data
    '''
    if not isinstance(h5data, hdf5):
        print h5data, " is not a valid FOCUS hdf5 file."
        return
    ncoil = h5data.Ncoils[0]  #array to index
    assert ncoil>0
    nf = h5data.NFcoil[0]
    assert nf>0
    if old:
        nseg = h5data.NDcoil[0]
    else:
        nseg = h5data.Nseg[0]
    assert nseg>0
    coilfou = np.reshape(h5data.coilspace[:,nn], (ncoil,-1)) #all coil data at nn time; and reshape
    coildata = np.ndarray((ncoil,),dtype=np.object)

    for icoil in range(ncoil):
        
        if old: #old format hdf5
            tmpfou = np.reshape(coilfou[icoil, 4:], (nf, 6))
            xyzfou = np.zeros([3, 2*nf+1], dtype=np.float64)
            xyzfou[0, 0] = coilfou[icoil, 1] #xc0
            xyzfou[1, 0] = coilfou[icoil, 2] #yc0
            xyzfou[2, 0] = coilfou[icoil, 3] #yc0
            xyzfou[0, 1:nf+1] = tmpfou[:, 0] #xc(1:n)
            xyzfou[1, 1:nf+1] = tmpfou[:, 1] #yc(1:n)
            xyzfou[2, 1:nf+1] = tmpfou[:, 2] #zc(1:n)
            xyzfou[0, nf+1:2*nf+1] = tmpfou[:, 3] #xs(1:n)
            xyzfou[1, nf+1:2*nf+1] = tmpfou[:, 4] #ys(1:n)
            xyzfou[2, nf+1:2*nf+1] = tmpfou[:, 5] #zs(1:n)
        else:
            xyzfou = np.reshape(coilfou[icoil,1:], (3,-1))  #pop current and reshape in 3 rows;
 
        coildata[icoil] = coil()
        coildata[icoil].I = coilfou[icoil,0]  #coil current;
        coildata[icoil].group = icoil
        coildata[icoil].x.extend(fourier(xyzfou[0,:]).disc(nseg))
        coildata[icoil].y.extend(fourier(xyzfou[1,:]).disc(nseg))
        coildata[icoil].z.extend(fourier(xyzfou[2,:]).disc(nseg))
    print "Read {} coils.".format(ncoil)
    return coildata

#------------------------------------------  13  ----------------------------------------------------

def coilevolve(h5data, Nfp=None, delay=250, nout=-1, old=False, savepng=False, aniname='coil_evolution', fps=10):
    '''
    plot coil evolution movie
    '''
    if not isinstance(h5data, hdf5):
        print h5data, " is not a valid FOCUS hdf5 file."
        return

    Ncoils = h5data.Ncoils[0]  #array to index
    assert Ncoils>0
    nf = h5data.NFcoil[0]
    assert nf>0
    if old:
        nseg = h5data.NDcoil[0]
    else:
        nseg = h5data.Nseg[0]
    assert nseg>0
    if nout < 0:
        if old:
            nout = h5data.itau[0]
        else:
            nout = h5data.iout[0] 
    assert nout>1
    if Nfp is None:
        if old:
            Nfp = 1
        else:
            Nfp = h5data.Nfp[0]
    unicoil = Ncoils/Nfp

    xx = np.zeros([Ncoils,nseg], dtype=np.float64)
    yy = np.zeros([Ncoils,nseg], dtype=np.float64)
    zz = np.zeros([Ncoils,nseg], dtype=np.float64)
    c = color_array(unicoil)
    coils = []

    # first coils
    coilfou = np.reshape(h5data.coilspace[:,0], (Ncoils,-1))
    for icoil in range(unicoil):
        if old: #old format hdf5
            tmpfou = np.reshape(coilfou[icoil, 4:], (nf, 6))
            xyzfou = np.zeros([3, 2*nf+1], dtype=np.float64)
            xyzfou[0, 0] = coilfou[icoil, 1] #xc0
            xyzfou[1, 0] = coilfou[icoil, 2] #yc0
            xyzfou[2, 0] = coilfou[icoil, 3] #yc0
            xyzfou[0, 1:nf+1] = tmpfou[:, 0] #xc(1:n)
            xyzfou[1, 1:nf+1] = tmpfou[:, 1] #yc(1:n)
            xyzfou[2, 1:nf+1] = tmpfou[:, 2] #zc(1:n)
            xyzfou[0, nf+1:2*nf+1] = tmpfou[:, 3] #xs(1:n)
            xyzfou[1, nf+1:2*nf+1] = tmpfou[:, 4] #ys(1:n)
            xyzfou[2, nf+1:2*nf+1] = tmpfou[:, 5] #zs(1:n)
        else:
            xyzfou = np.reshape(coilfou[icoil,1:], (3,-1))  #pop current and reshape in 3 rows;

        xx[icoil,:] = fourier(xyzfou[0,:]).disc(nseg)
        yy[icoil,:] = fourier(xyzfou[1,:]).disc(nseg)
        zz[icoil,:] = fourier(xyzfou[2,:]).disc(nseg)
        l = mlab.plot3d(xx[icoil,:], yy[icoil,:], zz[icoil,:], np.ones_like(xx[icoil,:]), color=c[icoil%unicoil])
        coils.append(l)

    @mlab.animate(delay=delay)
    def anim():
        for iout in range(nout):
            coilfou = np.reshape(h5data.coilspace[:,iout], (Ncoils,-1)) #all coil data at iout time;
            for icoil in range(unicoil):
                if old: #old format hdf5
                    tmpfou = np.reshape(coilfou[icoil, 4:], (nf, 6))
                    xyzfou = np.zeros([3, 2*nf+1], dtype=np.float64)
                    xyzfou[0, 0] = coilfou[icoil, 1] #xc0
                    xyzfou[1, 0] = coilfou[icoil, 2] #yc0
                    xyzfou[2, 0] = coilfou[icoil, 3] #yc0
                    xyzfou[0, 1:nf+1] = tmpfou[:, 0] #xc(1:n)
                    xyzfou[1, 1:nf+1] = tmpfou[:, 1] #yc(1:n)
                    xyzfou[2, 1:nf+1] = tmpfou[:, 2] #zc(1:n)
                    xyzfou[0, nf+1:2*nf+1] = tmpfou[:, 3] #xs(1:n)
                    xyzfou[1, nf+1:2*nf+1] = tmpfou[:, 4] #ys(1:n)
                    xyzfou[2, nf+1:2*nf+1] = tmpfou[:, 5] #zs(1:n)
                else:
                    xyzfou = np.reshape(coilfou[icoil,1:], (3,-1))  #pop current and reshape in 3 rows;

                xx[icoil,:] = fourier(xyzfou[0,:]).disc(nseg)
                yy[icoil,:] = fourier(xyzfou[1,:]).disc(nseg)
                zz[icoil,:] = fourier(xyzfou[2,:]).disc(nseg)
                coils[icoil].mlab_source.set(x=xx[icoil,:], y=yy[icoil,:], z=zz[icoil,:])
            mlab.title('iter = '+ str(iout), size=0.5)
            #print "savepng = ", savepng, iout
            if savepng :
                print "hi", iout
                filename = aniname+'_'+str(iout).zfill(6)+'.png'
                mlab.savefig(filename=filename)
            yield
        #mlab.close(mlab.clf())

    anim()
    mlab.show()
    if savepng:
        cmd = 'convert -delay {} -loop 0 {} {}'.format(10.0/fps, aniname+'_*.png', aniname+'.gif')
        subprocess.call(cmd, shell=True)
        subprocess.call("rm -f "+aniname+'_*.png', shell=True)

    return

#------------------------------------------  14  ----------------------------------------------------

def chievolve(h5data, term='chi', width = 2.5, linestyle='-', color='b'):
    '''
    plot chi-square cost functions evolution curves
    '''
    # check data type
    if not isinstance(h5data, hdf5):
        print h5data, " is not a valid FOCUS hdf5 file."
        return

    # get fig and axis
    if plt.get_fignums():
        fig = plt.gcf()
        ax = plt.gca()
    else :
        fig, ax = plt.subplots(facecolor = "white", figsize=[8,6], dpi=125)
        
    # get data
    iteration = range(len(h5data.evolution[0,:]))
    if term == 'chi':
        target = h5data.evolution[1,:]
        label = r'$ \chi^2$'
    elif term == 'deriv':
        target = h5data.evolution[2,:]
        label = r'$|d \chi^2 / d {\bf X}|$'
    elif term == 'bnorm':
        target = h5data.evolution[3,:]
        label = r'$ f_B$'     
    elif term == 'bharm':
        target = h5data.evolution[4,:]
        label = r'$ f_H$'    
    elif term == 'tflux':
        target = h5data.evolution[5,:]
        label = r'$ f_{\Psi}$'   
    elif term == 'ttlen':
        target = h5data.evolution[6,:]
        label = r'$ f_L$' 
    else :
        print term, " is not a valid option."
        return
    
    # plotting
    ax.semilogy(iteration, target, linewidth=width, label=label, linestyle=linestyle, color=color)
    plt.xticks(fontsize=16)
    plt.yticks(fontsize=16)
    plt.xlabel('iteration',fontsize=24)
    plt.ylabel(label,fontsize=24)
    plt.legend(loc='upper right', frameon=False, prop={'size':24, 'weight':'bold'})

    return

#------------------------------------------  15  ----------------------------------------------------

def plot_hdf5_surface(h5data, plottype='surf', color=(1,0,0) ):
    '''
    plot plasma surface from the hdf5 data

    plottype:
            'surf'      : just plot the surface with pure color;
            'targetBn'  : plot the surface with target Bn distribution;
            'realizedBn': plot the surface with realized Bn distribution;
            'Bmod'      : plot the surface with |B| distribution;
    '''

    if not isinstance(h5data, hdf5):
        print h5data, " is not a valid FOCUS hdf5 file."
        return

    # data manipulation
    nt =  h5data.Nteta[0] #opposite notation for nt & nz!
    nz =  h5data.Nzeta[0]  
    xx = np.zeros([nt+1,nz+1], dtype=np.float64)
    yy = np.zeros([nt+1,nz+1], dtype=np.float64)
    zz = np.zeros([nt+1,nz+1], dtype=np.float64)
    Bn = np.zeros([nt+1,nz+1], dtype=np.float64)
    Bm = np.zeros([nt+1,nz+1], dtype=np.float64)

    xx[0:nt, 0:nz] = np.transpose(h5data.xsurf[0:nz, 0:nt])
    xx[  nt, 0:nz] = xx[0   , 0:nz]
    xx[0:nt,   nz] = xx[0:nt, 0   ]
    xx[  nt,   nz] = xx[0   , 0   ]

    yy[0:nt, 0:nz] = np.transpose(h5data.ysurf[0:nz, 0:nt])
    yy[  nt, 0:nz] = yy[0   , 0:nz]
    yy[0:nt,   nz] = yy[0:nt, 0   ]
    yy[  nt,   nz] = yy[0   , 0   ]

    zz[0:nt, 0:nz] = np.transpose(h5data.zsurf[0:nz, 0:nt])
    zz[  nt, 0:nz] = zz[0   , 0:nz]
    zz[0:nt,   nz] = zz[0:nt, 0   ]
    zz[  nt,   nz] = zz[0   , 0   ]

    #plot
    if plottype == 'surf':
        mlab.mesh(xx, yy, zz, color=color)
    elif plottype == 'targetBn':
        for i in range(nz+1):
            ator = (i+0.5)*2*np.pi/nz #zeta
            for j in range(nt+1):
                apol = (j+0.5)*2*np.pi/nt #theta
                tmpBn = h5data.target_Bmnc*np.cos(h5data.Bmnim*apol-h5data.Bmnin*ator) \
                     + h5data.target_Bmns*np.sin(h5data.Bmnim*apol-h5data.Bmnin*ator)

                Bn[j,i] = np.sum(tmpBn)
        mlab.mesh(xx, yy, zz, scalars=Bn, colormap='coolwarm')
        axes = mlab.colorbar( orientation='vertical', label_fmt='%.1e')
        axes.title_text_property.font_family = 'times'
        axes.title_text_property.font_size = 6
        axes.title_text_property.italic = False
        axes.label_text_property.font_family = 'times'
        axes.label_text_property.font_size = 100
        axes.label_text_property.italic = False
    elif plottype == 'realizedBn':
        Bn[0:nt, 0:nz] = np.transpose(h5data.Bn[0:nz, 0:nt])
        Bn[  nt, 0:nz] = Bn[0   , 0:nz]
        Bn[0:nt,   nz] = Bn[0:nt, 0   ]
        Bn[  nt,   nz] = Bn[0   , 0   ]
        mlab.mesh(xx, yy, zz, scalars=Bn, colormap='coolwarm')
        axes = mlab.colorbar(orientation='vertical', label_fmt='%.1e')
        axes.title_text_property.font_family = 'times'
        axes.title_text_property.font_size = 6
        axes.title_text_property.italic = False
        axes.label_text_property.font_family = 'times'
        axes.label_text_property.font_size = 100
        axes.label_text_property.italic = False
    elif plottype == 'Bmod':
        Bm[0:nt, 0:nz] = np.transpose(np.sqrt(h5data.Bx*h5data.Bx +
                                              h5data.By*h5data.By +
                                              h5data.Bz*h5data.Bz ))
        Bm[  nt, 0:nz] = Bm[0   , 0:nz]
        Bm[0:nt,   nz] = Bm[0:nt, 0   ]
        Bm[  nt,   nz] = Bm[0   , 0   ]
        mlab.mesh(xx, yy, zz, scalars=Bm, colormap='coolwarm')
        #axes = mlab.colorbar(orientation='vertical', label_fmt='%.1e')
        #axes = mlab.colorbar( orientation='horizontal', label_fmt='%.2f')
        #axes.title_text_property.font_family = 'times'
        #axes.title_text_property.font_size = 8
        #axes.title_text_property.italic = False
    else :
        raise NameError("No such option!")
        print "plottype = surf/targetBn/realizedBn/Bmod"
    return

#------------------------------------------  16  ----------------------------------------------------
    
def read_focus(filename):
    '''
    filename : the path for the focus coils file
    return an array of focus class;
    '''
    if not os.path.exists(filename) :
        raise IOError ("File not existed. Please check again!")

    with open(filename,'r') as focusfile: 

        focusfile.readline()
        linelist = focusfile.readline().split()
        Ncoils = int(linelist[0])  # get the number of coils;

        focus_array = np.ndarray((Ncoils,),dtype=np.object) # intialize empty array;

        for icoil in range(Ncoils): # read each coils;
            
            focusfile.readline()
            focusfile.readline()

            linelist = focusfile.readline().split()
            itype = int(linelist[0])
            coilname = linelist[1]

            focusfile.readline()
            linelist = focusfile.readline().split()
            Nseg =   int(linelist[0])
            I    = float(linelist[1])
            Ic   =   int(linelist[2])
            L    = float(linelist[3])
            Lc   =   int(linelist[4])
            Lo   = float(linelist[5])
  
            focusfile.readline()
            linelist = focusfile.readline().split()
            NFcoil = int(linelist[0])
          
            focus_array[icoil] = focus(itype, NFcoil) # initialize with focus class;
            focus_array[icoil].name = coilname
            focus_array[icoil].NS    = Nseg
            focus_array[icoil].I    = I
            focus_array[icoil].Ic   = Ic
            focus_array[icoil].L    = L
            focus_array[icoil].Lc   = Lc
            focus_array[icoil].Lo   = Lo

            focusfile.readline()
            linelist = focusfile.readline().split()
            focus_array[icoil].xc = map(float, linelist)
            linelist = focusfile.readline().split()
            focus_array[icoil].xs = map(float, linelist)
            linelist = focusfile.readline().split()
            focus_array[icoil].yc = map(float, linelist)
            linelist = focusfile.readline().split()
            focus_array[icoil].ys = map(float, linelist)
            linelist = focusfile.readline().split()
            focus_array[icoil].zc = map(float, linelist)
            linelist = focusfile.readline().split()
            focus_array[icoil].zs = map(float, linelist)

    print "Read {} focus format coils in {}.".format(Ncoils, filename)
    return(focus_array)

#------------------------------------------  17  ----------------------------------------------------
    
def write_coils(coildata, filename, Nfp=1):
    '''
    coildata : coil or focus type of numpy object arrays;
    filename : the path for the focus coils file;

    write a file with filename
    '''
    Ncoils = len(coildata)  # coils number;
    assert Ncoils > 0

    if isinstance(coildata[0], focus) : # focus class type;
        print "Writing {} focus format coils to {}".format(Ncoils, filename)
        with open(filename, 'w') as wfile :
            wfile.write(" # Total number of coils \n")
            wfile.write("{:6d}\n".format(Ncoils))
            for icoil in range(Ncoils):
                wfile.write("#-----------------{}---------------------------\n".format(icoil+1))
                wfile.write("#coil_type     coil_name \n")
                wfile.write("   {:3d}    {:10}\n".format(coildata[icoil].itype, coildata[icoil].name))
                wfile.write("{:^6} {:^23} {:^6} {:^23} {:^6} {:^23}\n"\
                    .format(" #Nseg", "current",  "Ifree", "Length", "Lfree", "target_length"))
                wfile.write("{:^6d} {:^23.15E} {:^6d} {:^23.15E} {:^6d} {:^23.15E}\n"\
                   .format(coildata[icoil].NS, coildata[icoil].I, coildata[icoil].Ic, \
                               coildata[icoil].L, coildata[icoil].Lc, coildata[icoil].Lo))
                if coildata[icoil].itype == 1:
                    wfile.write("#NFcoil\n")
                    wfile.write("{:^7d}\n".format(coildata[icoil].NF))
                    wfile.write("#Fourier harmonics for coils ( xc; xs; yc; ys; zc; zs) \n")
                    for xyzcs in [coildata[icoil].xc, coildata[icoil].xs, coildata[icoil].yc, \
                                      coildata[icoil].ys, coildata[icoil].zc, coildata[icoil].zs] :
                        for ixyzcs in xyzcs:
                            wfile.write("{:23.15E} ".format(ixyzcs))
                        wfile.write(" \n")
            wfile.write("end \n")
    elif isinstance(coildata[0], coil) : #coil class type;
        print "Writing {} coil format coils in {} periods to {}".format(Ncoils*Nfp, Nfp, filename)
        allcoil = map_coils(coildata, Nfp)  # map coils if necessary;
        with open(filename, 'w') as wfile :
            wfile.write("periods {:3d} \n".format(Nfp))
            wfile.write("begin filament \n")
            wfile.write("mirror NIL \n")
            for icoil in allcoil:
                Nseg = len(icoil.x) # number of segments;
                assert Nseg > 1
                for iseg in range(Nseg-1): # the last point match the first one;
                    wfile.write("{:23.15E} {:23.15E} {:23.15E} {:23.15E}\n".format(icoil.x[iseg], icoil.y[iseg], icoil.z[iseg], icoil.I))
                wfile.write("{:23.15E} {:23.15E} {:23.15E} {:23.15E} {:6d} {:10} \n".format(icoil.x[0], icoil.y[0], icoil.z[0], 0.0, icoil.group, icoil.name))
            wfile.write("end \n")
    else :
        raise TypeError("Invalid data!")
        print "Please use either focus or coil class type data."
    return

#------------------------------------------  18  ----------------------------------------------------
    
def map_coils(coildata, Nfp):
    '''
    coildata : coil or focus type of numpy object arrays;
    Nfp      : number of field periodicity

    return a numpy object array with all the coils;
    '''
    assert Nfp >= 1
    if Nfp == 1:
        return coildata
    else:
        Nuniq = len(coildata)
        Ncoils = Nuniq * Nfp
        allcoil = np.ndarray((Ncoils,),dtype=np.object) # intialize empty array;

        for ifp in range(Nfp):
            cosphi = np.cos(2.0*ifp*np.pi/Nfp)            
            sinphi = np.sin(2.0*ifp*np.pi/Nfp)
            # copy the coils data;
            for icoil in range(Nuniq):
                allcoil[icoil + ifp*Nuniq] = coil() #initialize empty class;
                allcoil[icoil + ifp*Nuniq].I     = coildata[icoil].I
                allcoil[icoil + ifp*Nuniq].group = coildata[icoil].group
                allcoil[icoil + ifp*Nuniq].name  = coildata[icoil].name
                allcoil[icoil + ifp*Nuniq].z.extend(coildata[icoil].z)

                allcoil[icoil + ifp*Nuniq].x.extend(  np.array(coildata[icoil].x) * cosphi \
                                                    - np.array(coildata[icoil].y) * sinphi )
                allcoil[icoil + ifp*Nuniq].y.extend(  np.array(coildata[icoil].x) * sinphi \
                                                    + np.array(coildata[icoil].y) * cosphi )                
        return allcoil

#------------------------------------------  19  ----------------------------------------------------

def coilperturb(x0, dx, delta, nf, Ncoils, nouts=100, delay=250, old = True,
                savepng=False, gifname='perturbation', fps=2):
    '''
    plot coil perturbation movie
    '''

    width = 2.5
    nseg = 128

    if old:
        nfp = 1
    else:
        nfp = h5data.Nfp[0]
    unicoil = Ncoils/nfp

    xx = np.zeros([Ncoils,nseg], dtype=np.float32)
    yy = np.zeros([Ncoils,nseg], dtype=np.float32)
    zz = np.zeros([Ncoils,nseg], dtype=np.float32)
    c = color_array(unicoil)
    coils = []

    #initial status;
    coilinit = np.reshape(x0, (Ncoils,-1))
    for icoil in range(unicoil):
        if old: #old format hdf5
            tmpfou = np.reshape(coilinit[icoil, 4:], (nf, 6))
            xyzfou = np.zeros([3, 2*nf+1], dtype=np.float32)
            xyzfou[0, 0] = coilinit[icoil, 1] #xc0
            xyzfou[1, 0] = coilinit[icoil, 2] #yc0
            xyzfou[2, 0] = coilinit[icoil, 3] #yc0
            xyzfou[0, 1:nf+1] = tmpfou[:, 0] #xc(1:n)
            xyzfou[1, 1:nf+1] = tmpfou[:, 1] #yc(1:n)
            xyzfou[2, 1:nf+1] = tmpfou[:, 2] #zc(1:n)
            xyzfou[0, nf+1:2*nf+1] = tmpfou[:, 3] #xs(1:n)
            xyzfou[1, nf+1:2*nf+1] = tmpfou[:, 4] #ys(1:n)
            xyzfou[2, nf+1:2*nf+1] = tmpfou[:, 5] #zs(1:n)
        else:
            xyzfou = np.reshape(coilinit[icoil,1:], (3,-1))  #pop current and reshape in 3 rows;

        mlab.plot3d(fourier(xyzfou[0,:]).disc(nseg), fourier(xyzfou[1,:]).disc(nseg),
                    fourier(xyzfou[2,:]).disc(nseg), np.ones_like(fourier(xyzfou[0,:]).disc(nseg)), 
                    line_width=width, color=(0.5, 0.5, 0.5))

    # first coils
    coilfou = np.reshape(x0-delta*dx, (Ncoils,-1))
    for icoil in range(unicoil):
        if old: #old format hdf5
            tmpfou = np.reshape(coilfou[icoil, 4:], (nf, 6))
            xyzfou = np.zeros([3, 2*nf+1], dtype=np.float32)
            xyzfou[0, 0] = coilfou[icoil, 1] #xc0
            xyzfou[1, 0] = coilfou[icoil, 2] #yc0
            xyzfou[2, 0] = coilfou[icoil, 3] #yc0
            xyzfou[0, 1:nf+1] = tmpfou[:, 0] #xc(1:n)
            xyzfou[1, 1:nf+1] = tmpfou[:, 1] #yc(1:n)
            xyzfou[2, 1:nf+1] = tmpfou[:, 2] #zc(1:n)
            xyzfou[0, nf+1:2*nf+1] = tmpfou[:, 3] #xs(1:n)
            xyzfou[1, nf+1:2*nf+1] = tmpfou[:, 4] #ys(1:n)
            xyzfou[2, nf+1:2*nf+1] = tmpfou[:, 5] #zs(1:n)
        else:
            xyzfou = np.reshape(coilfou[icoil,1:], (3,-1))  #pop current and reshape in 3 rows;

        xx[icoil,:] = fourier(xyzfou[0,:]).disc(nseg)
        yy[icoil,:] = fourier(xyzfou[1,:]).disc(nseg)
        zz[icoil,:] = fourier(xyzfou[2,:]).disc(nseg)
        l = mlab.plot3d(xx[icoil,:], yy[icoil,:], zz[icoil,:], np.ones_like(xx[icoil,:]), line_width=width, color=c[icoil])
        coils.append(l)

    @mlab.animate(delay=delay)
    def anim():
        for iout in range(nouts+1):
            coilfou = np.reshape(x0+(np.float(2*iout)/nouts-1)*delta*dx, (Ncoils,-1)) #all coil data at iout time;
            for icoil in range(unicoil):
                if old: #old format hdf5
                    tmpfou = np.reshape(coilfou[icoil, 4:], (nf, 6))
                    xyzfou = np.zeros([3, 2*nf+1], dtype=np.float32)
                    xyzfou[0, 0] = coilfou[icoil, 1] #xc0
                    xyzfou[1, 0] = coilfou[icoil, 2] #yc0
                    xyzfou[2, 0] = coilfou[icoil, 3] #yc0
                    xyzfou[0, 1:nf+1] = tmpfou[:, 0] #xc(1:n)
                    xyzfou[1, 1:nf+1] = tmpfou[:, 1] #yc(1:n)
                    xyzfou[2, 1:nf+1] = tmpfou[:, 2] #zc(1:n)
                    xyzfou[0, nf+1:2*nf+1] = tmpfou[:, 3] #xs(1:n)
                    xyzfou[1, nf+1:2*nf+1] = tmpfou[:, 4] #ys(1:n)
                    xyzfou[2, nf+1:2*nf+1] = tmpfou[:, 5] #zs(1:n)
                else:
                    xyzfou = np.reshape(coilfou[icoil,1:], (3,-1))  #pop current and reshape in 3 rows;

                xx[icoil,:] = fourier(xyzfou[0,:]).disc(nseg)
                yy[icoil,:] = fourier(xyzfou[1,:]).disc(nseg)
                zz[icoil,:] = fourier(xyzfou[2,:]).disc(nseg)
                coils[icoil].mlab_source.set(x=xx[icoil,:], y=yy[icoil,:], z=zz[icoil,:])
            mlab.title('delta = '+ str((np.float(2*iout)/nouts-1)*delta), size=0.4)
            if savepng :
                filename = gifname+'_'+str(iout).zfill(6)+'.png'
                mlab.savefig(filename=filename)
            yield
        mlab.close(mlab.clf())
    anim()
    mlab.show()

    tt = np.linspace(-delta, delta, nouts)
    I0 = x0[0::(6*nf+4)]
    dI = dx[0::(6*nf+4)]
    for icoil in range(unicoil):
        plt.plot(tt, I0[icoil]+dI[icoil]*tt, label='coil_'+str(icoil))
    
    plt.legend(loc=1)
    plt.show()
    

    #write gif
    if savepng:
        cmd = 'convert -delay {} -loop 0 {} {}'.format(10.0/fps, aniname+'_*.png', aniname+'.gif')
        subprocess.call(cmd, shell=True)
        subprocess.call("rm -f "+gifname+'_*.png', shell=True)

    return

#------------------------------------------  20  ----------------------------------------------------

def surfnorm(x, y, z, WindSurf, tol=1E-3):
    '''
    x, y, z  : xyz coordinates
    WindSurf : toroidal surface data 
    '''
    #tol = 2.5E-2  # the tolerance

    # find theta, phi corresponding to xyz
    R = np.sqrt(x**2 + y**2)
    if   x >  0.0 and y >= 0.0 : # [0,pi/2)
        phi = np.arcsin(y/R)
    elif x <= 0.0 and y >  0.0 : # [pi/2, pi)
        phi = np.arccos(x/R)
    elif x <  0.0 and y <= 0.0 : # [pi, 3/2 pi)
        phi = np.arccos(-x/R) + np.pi
    elif x >= 0.0 and y <  0.0 : # [3/2 pi, 2pi)
        phi = np.arcsin(y/R) + 2*np.pi
    
    def f(theta, phi, R0, z0, WindSurf):
        return    ( np.sum( WindSurf['Zbc']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) + \
                            WindSurf['Zbs']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) ) - z0)**2 + \
                  ( np.sum( WindSurf['Rbc']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) + \
                            WindSurf['Rbs']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) ) - R0)**2

    
    res = optimize.minimize(f, 0.0, args=(phi, R, z, WindSurf), method='Powell')
    if res.success :
        theta = np.asscalar(res.x)
    else :
        print res.message

    R2 = np.sum( WindSurf['Rbc']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) + \
                 WindSurf['Rbs']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) )

    if abs(R2-R) > tol :
        theta = optimize.fminbound(f, 0, 2*np.pi, args=(phi, R, z, WindSurf), xtol=1e-20)
        
    R3 = np.sum( WindSurf['Rbc']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) + \
                 WindSurf['Rbs']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) )
    if abs(R3-R) > tol*10 :
        print "R, R2, R3 = ", R, R2, R3, " ; theta, phi = ", theta, phi
        print "x, y, z = ", x, y, z, "|z-z0| = ", f(theta, phi, R, z, WindSurf)
        raise ValueError("The curve might not on the surface.")
    
    # calculate nx, ny, nz
    Rt = np.sum(- WindSurf['m'] * WindSurf['Rbc']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) + \
                  WindSurf['m'] * WindSurf['Rbs']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) )
    Rp = np.sum(  WindSurf['n'] * WindSurf['Rbc']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) + \
                - WindSurf['n'] * WindSurf['Rbs']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) )

    zt = np.sum(- WindSurf['m'] * WindSurf['Zbc']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) + \
                  WindSurf['m'] * WindSurf['Zbs']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) )
    zp = np.sum(  WindSurf['n'] * WindSurf['Zbc']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) + \
                - WindSurf['n'] * WindSurf['Zbs']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) )

    xt = Rt * np.cos(phi)
    xp = Rp * np.cos(phi) - R * np.sin(phi)
    yt = Rt * np.sin(phi)
    yp = Rp * np.sin(phi) + R * np.cos(phi)

    nx = zt*yp - zp*yt
    ny = xt*zp - xp*zt
    nz = yt*xp - yp*xt

    nn = np.sqrt(nx**2 + ny**2 + nz**2)
    return  nx/nn,  ny/nn, nz/nn

#------------------------------------------  21  ----------------------------------------------------

def fourier2coil(x0, nf, ncoil, old=False, nseg=128):
    '''
    vector of free variables to coil data
    '''
    
    coildata = np.ndarray((ncoil,),dtype=np.object)
    
    coilfou = np.reshape(x0, (ncoil,-1))
    I0 = x0[0::(6*nf+4)]
    
    for icoil in range(ncoil):
        coildata[icoil] = coil()
        if old: #old format hdf5
            tmpfou = np.reshape(coilfou[icoil, 4:], (nf, 6))
            xyzfou = np.zeros([3, 2*nf+1], dtype=np.float32)
            xyzfou[0, 0] = coilfou[icoil, 1] #xc0
            xyzfou[1, 0] = coilfou[icoil, 2] #yc0
            xyzfou[2, 0] = coilfou[icoil, 3] #yc0
            xyzfou[0, 1:nf+1] = tmpfou[:, 0] #xc(1:n)
            xyzfou[1, 1:nf+1] = tmpfou[:, 1] #yc(1:n)
            xyzfou[2, 1:nf+1] = tmpfou[:, 2] #zc(1:n)
            xyzfou[0, nf+1:2*nf+1] = tmpfou[:, 3] #xs(1:n)
            xyzfou[1, nf+1:2*nf+1] = tmpfou[:, 4] #ys(1:n)
            xyzfou[2, nf+1:2*nf+1] = tmpfou[:, 5] #zs(1:n)
        else:
            xyzfou = np.reshape(coilfou[icoil,1:], (3,-1))  #pop current and reshape in 3 rows;

        coildata[icoil].x = fourier(xyzfou[0,:]).disc(nseg)
        coildata[icoil].y = fourier(xyzfou[1,:]).disc(nseg)
        coildata[icoil].z = fourier(xyzfou[2,:]).disc(nseg)
        coildata[icoil].I = I0[icoil]
    return coildata

#------------------------------------------  22  ----------------------------------------------------
def vmec2focus(vmec_file, focus_file='plasma.boundary', bnorm_file = None, ns=-1,
               curpol = 1.0, flipsign=False, tol=10E-6):
    '''
    vmec_file : VMEC  input/output file, input* / wout*;
    focus_file: FOCUS input file input*;
    bnorm_file: BNORM output file, bnorm*; Bn = sin(mu+nv), but in FOUCS Bn=cos(mu-nv) + sin(mu-nv)
    curpol    : poloidal current, read from VMEC output or by hand;
    old       : old version or new version FOCUS (they have different sign);
    tol       : truncation tolarence;

    // Compute net poloidal current required to produce vacuum toroidal field.
    // Note: The vacuum toroidal field produced by coils goes like 1/R,
    //  so R*B0 is constant. If RB0 is in Tesla-meters, then the required
    // current in amps to produce it is 2*pi*R*B0/mu_0, where mu_0 = 4*pi*1e-7,
    // or 5e+6 * RB0. (VMEC values absorb the mu_0 factor and are normalized
    //  to unit current/field period, so curpol_vmec = 2*pi*R*B0/nfper, i.e.,
    //  curpol_vmec = mu0 * reqpolcur_A / nfper = mu0 * 5e+6 * RB0 / nfper).

    '''
    # read vmec data
    # rbc(n,m)   {n=-ntor, +ntor (for m=0, only half)}  {m=0, +mpol-1}  
    if 'wout' in vmec_file: # netcdf format VMEC output
        wout = ncdata.open_dataset(vmec_file)
        mpol = int(wout['mpol'].values)
        ntor = int(wout['ntor'].values)
        rmnc = wout['rmnc'].values
        zmns = wout['zmns'].values
        rbc = rmnc[ns,:]
        zbs = zmns[ns,:]
        Nfp = int(wout['nfp'].values)
        #curpol = 5.0e6 * wout['rbtor0'].values / Nfp * (4*np.pi*1.0e-7) 
        curpol = 2.0*np.pi / Nfp * wout['rbtor'].values  # not rbtor0, it's rbtor
        print "Total poloidal current needed is ", 5.0*wout['rbtor'].values, " MA."
    elif 'input' in vmec_file: # input namelist of VMEC
        indata = f90nml.read(vmec_file)['indata']
        mpol = int(indata['mpol'])
        ntor = int(indata['ntor'])
        Nfp  = int(indata['nfp' ])
        rbc_ori  = np.ravel(np.array(indata['rbc'], dtype=np.float)) # one row
        zbs_ori  = np.ravel(np.array(indata['zbs'], dtype=np.float)) # one row
        rbc = [ibc if not np.isnan(ibc) else 0.0 for ibc in rbc_ori] # replace nan symbol with 0.0
        zbs = [ibs if not np.isnan(ibs) else 0.0 for ibs in zbs_ori]
    else:
        print "Please check your first argument. It should be wout* or input*."
    
    def vmecMN(mpol, ntor):
    # manipulate VMEC index
        mn = (2*ntor+1)*mpol - ntor # total number of Fourier harmonics
        xm = np.zeros((mn,), dtype=int)
        xn = np.zeros((mn,), dtype=int)
        imn = 0 
        for ii in range(mpol):
            for jj in range(-ntor, ntor+1):
                if ii==0 and jj<0 :
                    continue
                xm[imn] = ii
                xn[imn] = jj
                imn += 1
        return xm, xn
    
    # create VMEC index
    xm, xn = vmecMN(mpol, ntor)
    mn = (2*ntor+1)*mpol - ntor # total number of Fourier harmonics
    
    # BNORM output
    if bnorm_file is None : # no bnorm
        Nbnf = 0
    else :  # read BNORM file
        bm = []
        bn = []
        bns = []
        #bnc = []
        with open(bnorm_file, 'r') as bfile:
            for line in bfile:
                tmp = line.split() # BNORM format: m n Bn_sin
                bm.append(int(tmp[0]))
                bn.append(int(tmp[1]))                
                bns.append(float(tmp[2]))
        Nbnf = len(bm)
        bnc = np.zeros(Nbnf)
        bns = np.array(bns)*curpol
        print "Read ", Nbnf, " harmonics in BNORM file. M =", max(bm), ", N =", max(bn)
    
    # write FOCUS input
    amn = 0
    for imn in range(mn):
        if (abs(rbc[imn])+abs(zbs[imn])) > tol :
            amn += 1 # number of nonzero coef.
    with open(focus_file, 'w') as fofile:
        fofile.write('# bmn   bNfp   nbf '+'\n')
        fofile.write("{:d} \t {:d} \t {:d} \n".format(amn, Nfp, Nbnf))
        fofile.write('#plasma boundary'+'\n')
        fofile.write('# n m Rbc Rbs Zbc Zbs'+'\n')
        for imn in range(mn):
            if (abs(rbc[imn])+abs(zbs[imn])) > tol :
                fofile.write("{:4d}  {:4d} \t {:23.15E}  {:23.15E}  {:23.15E}  {:23.15E} \n".format(
                        xn[imn], xm[imn], rbc[imn], 0.0, 0.0, zbs[imn]))
        fofile.write("#Bn harmonics curpol= {:23.15E} ; I_p={:23.15E} \n".format(curpol, 5.0*wout['rbtor'].values))
        fofile.write('# n m bnc bns'+'\n')
        if flipsign : # flip the sign of bns
            for imn in range(Nbnf):
                fofile.write("{:d} \t {:d} \t {:23.15E} \t {:23.15E} \n".format(-bn[imn], bm[imn], 0.0, -bns[imn])) 
                # negative n, because FOCUS and BNORM are taking different rep.
        else :
            for imn in range(Nbnf):
                fofile.write("{:d} \t {:d} \t {:23.15E} \t {:23.15E} \n".format(-bn[imn], bm[imn], 0.0, bns[imn])) 
                # negative n, because FOCUS and BNORM are taking different rep.           
    print "Finished write FOCUS input file at ", focus_file
    return

#------------------------------------------  23  ----------------------------------------------------
def plot_fieldlines(filename, plottype='basic', cutplane=0, color='k', dotsize=0.1):
    '''
    plot the hdf5 file from FIELDLINES.
    filename: the filename of hdf5 output;
    plottype: plot type, 
              basic: Poincare plot at one plane; 
              sparse: less dense plot;
    cutplane: the specific plane for Poincare plot;
    color: scatter color;
    dotsize: scatter dot size;
    '''
    data = hdf5(filename)
    line_dex = range(cutplane, data.nsteps, data.npoinc) # data index
    if plottype == 'basic':
        lines = range(data.nlines)
    elif plottype == 'sparse':
        lines = range(0, data.nlines, 2)
    else:
        print "unsupported plottype!"
        return
    for i in lines:
        plt.scatter(data.R_lines[line_dex, i], data.Z_lines[line_dex, i], dotsize, color=color)
    plt.axis('equal')
    plt.xlabel('R [m]',fontsize=20)
    plt.ylabel('Z [m]',fontsize=20)
    plt.xticks(fontsize=16)
    plt.yticks(fontsize=16)
    plt.tight_layout()
    return   

#------------------------------------------  24  ----------------------------------------------------
def compare_dataset(data1, data2, tol=1E-8):
    '''
    compare the variables in two datasets, data1 and data2
    '''
    names = data1.keys()
    for var in names:
        # this is suitable for netcdf read by scipy.io
        dif = data1[var][()] - data2[var][()]
        if np.max(abs(dif)) / np.max(abs(data1[var][()])) > tol :
            print 'Found different term :', var
                                    

#------------------------------------------  25  ----------------------------------------------------
def mgrid_location(mgrid_file, position, extcur=None, xyz=True):
    '''
    return the magnetic field at a position in a mgrid file
    mgrid_file: file name in netcdf format
    position(0:2): coordinates of the evaluation point
    extcur(0:n-1): over-written the raw values of the currents
    xyz: using cartesian or cylinder coordinates
    '''
    mgrid = ncdata.open_dataset(mgrid_file)
    nextcur = mgrid['nextcur'].values # No. of current groups
    if extcur is None:
        extcur = mgrid['raw_coil_cur'].values
    assert len(extcur) == nextcur
    nr = mgrid['ir'].values  # R
    nz = mgrid['jz'].values  # Z
    nphi = mgrid['kp'].values  # Phi
    
    rmin = mgrid['rmin'].values
    rmax = mgrid['rmax'].values
    zmin = mgrid['zmin'].values
    zmax = mgrid['zmax'].values
    nfp = mgrid['nfp'].values

    '''
    i in [0, N-1]
    r = (rmax-rmin)*i/(nr-1)
    z = (zmax-zmin)*i/(nz-1)
    phi = (2Pi/nfp)*i/nphi
    '''
    
    if xyz :
        # get R, Phi, Z
        x = position[0]
        y = position[1]
        R = np.sqrt(position[0]**2 + position[1]**2)
        if   x >  0.0 and y >= 0.0 : # [0,pi/2)
            phi = np.arcsin(y/R)
        elif x <= 0.0 and y >  0.0 : # [pi/2, pi)
            phi = np.arccos(x/R)
        elif x <  0.0 and y <= 0.0 : # [pi, 3/2 pi)
            phi = np.arccos(-x/R) + np.pi
        elif x >= 0.0 and y <  0.0 : # [3/2 pi, 2pi)
            phi = np.arcsin(y/R) + 2*np.pi
        Phi = np.mod(phi, 2*np.pi/nfp)
        Z = position[2]
    else :
        R = position[0]
        Phi = np.mod(position[1], 2*np.pi/nfp)
        Z = position[2]
        
    # get index
    ir = np.int( np.rint( (R-rmin)/(rmax-rmin)*(nr-1) ) )
    ip = np.int( np.rint( Phi/(2*np.pi)*nfp*nphi ) )
    iz = np.int( np.rint( (Z-zmin)/(zmax-zmin)*(nz-1) ) )
    
    # print ir, ip, iz

    new_R = rmin + ir*(rmax-rmin)/(nr-1)
    new_phi = ip*2*np.pi/nfp/nphi
    new_Z = zmin + iz*(zmax-zmin)/(nz-1)

    print 'Closest point in (R, phi, Z): ', new_R, new_phi, new_Z
    
    # get magnetic field
    for ic in range(nextcur):
        if ic == 0:
            br = mgrid['br_001'].values * extcur[ic]
            bp = mgrid['bp_001'].values * extcur[ic]
            bz = mgrid['bz_001'].values * extcur[ic]
        else :
            br += mgrid['br_'+str(ic+1).zfill(3)].values * extcur[ic]
            bp += mgrid['bp_'+str(ic+1).zfill(3)].values * extcur[ic]
            bz += mgrid['bz_'+str(ic+1).zfill(3)].values * extcur[ic]
    
    # return magnetic field
    if xyz:
        B1 = br[ip, iz, ir] * np.cos(new_phi) - bp[ip, iz, ir] * np.sin(new_phi) # Bx
        B2 = br[ip, iz, ir] * np.sin(new_phi) + bp[ip, iz, ir] * np.cos(new_phi) # By
        B3 = bz[ip, iz, ir] # Bz
        print 'returned B field in cartesian.'
    else:
        B1 = br[ip, iz, ir] # Br
        B2 = bp[ip, iz, ir] # Bp
        B3 = bz[ip, iz, ir] # Bz
        print 'returned B field in cylinder.'
    
    return np.array([B1, B2, B3])


#------------------------------------------  26  ----------------------------------------------------
def compare_bn(focus_file, plottype='all', old=True, cmap='coolwarm'):
    '''
    Plot the target/realized Bn distribution on the theta-zeta plane.
    '''
    h5file = hdf5(focus_file)
    fig = plt.figure(figsize=[4,6])
    #fig, axes = plt.subplots(nrows=2, ncols=1)
    ax1 = plt.subplot(311)
    ax2 = plt.subplot(312, sharex=ax1)
    ax3 = plt.subplot(313, sharex=ax1)
    vm = np.min([h5file.tgtBn, h5file.curBn])
    vn = np.max([h5file.tgtBn, h5file.curBn])
    im1 = ax1.imshow(np.transpose(h5file.tgtBn), vmin=vm, vmax=vn, cmap=cmap)
    im2 = ax2.imshow(np.transpose(h5file.curBn), vmin=vm, vmax=vn, cmap=cmap)
    im3 = ax3.imshow(np.transpose(h5file.curBn-h5file.tgtBn), vmin=vm, vmax=vn, cmap=cmap)
    ax1.set_title('target Bnormal')
    ax2.set_title('realized Bnormal')
    ax3.set_title('difference')
    #ax1.set_xlabel(r'$\phi$')
    plt.setp(ax1.get_xticklabels(), visible=False)
    plt.setp(ax2.get_xticklabels(), visible=False)
    ax3.set_xlabel(r'$\phi$', fontsize=14)
    ax1.set_ylabel(r'$\theta$', fontsize=14)
    ax2.set_ylabel(r'$\theta$', fontsize=14)
    ax3.set_ylabel(r'$\theta$', fontsize=14)
    
    nz, nt = np.shape(h5file.tgtBn)
    #print nt, nz
    plt.setp(ax3, xticks=[0, nz/4, nz/2, 3*nz/4, nz], xticklabels=[r'0', r'$\pi$/2',r'$\pi$', r'3$\pi$/2', r'$2\pi$'] )
    plt.setp(ax1, yticks=[0, nt/4, nt/2, 3*nt/4, nt], yticklabels=[r'0', r'$\pi$/2',r'$\pi$', r'3$\pi$/2', r'$2\pi$'] )
    plt.setp(ax2, yticks=[0, nt/4, nt/2, 3*nt/4, nt], yticklabels=[r'0', r'$\pi$/2',r'$\pi$', r'3$\pi$/2', r'$2\pi$'] )
    plt.setp(ax3, yticks=[0, nt/4, nt/2, 3*nt/4, nt], yticklabels=[r'0', r'$\pi$/2',r'$\pi$', r'3$\pi$/2', r'$2\pi$'] )
    fig.subplots_adjust(right=0.80)
    cbar_ax = fig.add_axes([0.82, 0.10, 0.04, 0.8])
    fig.colorbar(im2, cax=cbar_ax)

    return

#------------------------------------------  27  ----------------------------------------------------
def plot_winding_surface(filename,plottype='cross-section',zeta=0.0, zeta1=2*np.pi, 
                         style='-',width=2.0,lbl='Target boundary',npol=128,ntor=128,
                         location = False, **kwargs):
    '''
    plot the winding surface;
    plottype:
            cross-section -> 2D plot at zeta plane
            surface       -> 3D surface using matplotlib
            surface3d     -> 3D surface using mayavi
    '''
    with open(filename, 'r') as f:
        line = ''
        while "np     iota_edge       phip_edge       curpol" not in line:
            line = f.readline()
        line = f.readline()
        nfp = int(line.split()[0])
        print "nfp:",nfp

        line = ''
        while "------ Current Surface:" not in line:
            line = f.readline()
        line = f.readline()
        line = f.readline()
        print "Number of Fourier modes in coil surface from nescin file: ",line
        num = int(line)
        plas = np.zeros(num, dtype=[('m',np.float64), ('n', np.float64), #m,n saving as double
                                         ('Rbc', np.float64), ('Zbs', np.float64),
                                         ('Rbs', np.float64), ('Zbc', np.float64) ])
        line = f.readline() #skip one line
        line = f.readline() #skip one line
        for i in range(num):
            line = f.readline()
            plas[i] = tuple([float(j) for j in line.split()])
        plas['n'] *= nfp
    #print np.max(plas['Rbc']), np.max(plas['Rbs']), np.max(plas['Zbc']), np.max(plas['Zbs'])
    # ploting
    maxR, minR, maxZ, minZ = 0.0, 999.0, 0.0, 999.0
    if plottype=='cross-section' : #plot cross-section
        npoints = 360 #number of points
        theta = np.linspace(0,2* np.pi, npoints)
        r = np.zeros(npoints)
        z = np.zeros(npoints)
        for ipoint in range(npoints):
            tmpr = plas['Rbc']*np.cos(plas['m']*theta[ipoint]+plas['n']*zeta) + \
                   plas['Rbs']*np.sin(plas['m']*theta[ipoint]+plas['n']*zeta)
            r[ipoint] = np.sum(tmpr) #r value at ipont
            maxR = max(np.sum(tmpr), maxR)
            minR = min(np.sum(tmpr), minR)

            tmpz = plas['Zbc']*np.cos(plas['m']*theta[ipoint]+plas['n']*zeta) + \
                   plas['Zbs']*np.sin(plas['m']*theta[ipoint]+plas['n']*zeta)
            z[ipoint] = np.sum(tmpz) #z value at ipont
            maxZ = max(np.sum(tmpz), maxZ)
            minZ = min(np.sum(tmpz), minZ)
        if plt.get_fignums():
            fig = plt.gcf()
            ax = plt.gca()
        else :
            fig, ax = plt.subplots()
        ax.plot(r, z,linewidth=width,linestyle=style,label=lbl, **kwargs)
        if location:
            for ang in [0, np.pi/2]:
                tmpr = plas['Rbc']*np.cos(plas['m']*ang-plas['n']*zeta) + \
                    plas['Rbs']*np.sin(plas['m']*ang-plas['n']*zeta)
                tmpr = np.sum(tmpr) #r value at ipont
                tmpz = plas['Zbc']*np.cos(plas['m']*ang-plas['n']*zeta) + \
                    plas['Zbs']*np.sin(plas['m']*ang-plas['n']*zeta)
                tmpz = np.sum(tmpz) #z value at ipont
                ax.text(tmpr, tmpz, '{:} pi'.format(ang/np.pi), **kwargs)
        plt.axis('equal')
        plt.xlabel('R [m]',fontsize=20)
        plt.ylabel('Z [m]',fontsize=20)
        plt.xticks(fontsize=16)
        plt.yticks(fontsize=16)
        plt.tight_layout()
        return maxR, minR, maxZ, minZ
    elif plottype == 'surface' : #plot surface
        if plt.get_fignums():
            fig = plt.gcf()
        else :
            fig = plt.figure()
        ax = fig.gca(projection='3d')
        x=np.zeros((npol+1,ntor+1))
        y=np.zeros((npol+1,ntor+1))
        z=np.zeros((npol+1,ntor+1))
        for i in range(ntor+1):
            ator = zeta + i*(zeta1-zeta)/ntor #zeta
            for j in range(npol+1):
                apol = j*2*np.pi/npol #theta
                tmpr = plas['Rbc']*np.cos(plas['m']*apol+plas['n']*ator) + \
                       plas['Rbs']*np.sin(plas['m']*apol+plas['n']*ator)
                tmpz = plas['Zbc']*np.cos(plas['m']*apol+plas['n']*ator) + \
                       plas['Zbs']*np.sin(plas['m']*apol+plas['n']*ator)
                maxR = max(np.sum(tmpr), maxR)
                minR = min(np.sum(tmpr), minR)
                maxZ = max(np.sum(tmpz), maxZ)
                minZ = min(np.sum(tmpz), minZ)
                x[j,i] = np.sum(tmpr) * np.cos(ator)
                y[j,i] = np.sum(tmpr) * np.sin(ator)
                z[j,i] = np.sum(tmpz)
        ax.plot_surface(x,y,z,color='white')
        #p1 = [x[npol/2  ,ntor/2  ], y[npol/2  ,ntor/2  ], z[npol/2  ,ntor/2  ]]
        #p2 = [x[npol/2+1,ntor/2  ], y[npol/2+1,ntor/2  ], z[npol/2+1,ntor/2  ]]
        #p3 = [x[npol/2  ,ntor/2+1], y[npol/2  ,ntor/2+1], z[npol/2  ,ntor/2+1]]
        #p4 = [x[npol/2+1,ntor/2+1], y[npol/2+1,ntor/2+1], z[npol/2+1,ntor/2+1]]
        return maxR, minR, maxZ, minZ
    elif plottype == 'surface3d' :
        x=np.zeros((npol+1,ntor+1))
        y=np.zeros((npol+1,ntor+1))
        z=np.zeros((npol+1,ntor+1))

        for i in range(ntor+1):
            ator = zeta + (i+0.5)*(zeta1-zeta)/ntor #zeta
            for j in range(npol+1):
                apol = (j+0.5)*2*np.pi/npol #theta
                tmpr = plas['Rbc']*np.cos(plas['m']*apol+plas['n']*ator) + \
                       plas['Rbs']*np.sin(plas['m']*apol+plas['n']*ator)
                tmpz = plas['Zbc']*np.cos(plas['m']*apol+plas['n']*ator) + \
                       plas['Zbs']*np.sin(plas['m']*apol+plas['n']*ator)
                maxR = max(np.sum(tmpr), maxR)
                minR = min(np.sum(tmpr), minR)
                maxZ = max(np.sum(tmpz), maxZ)
                minZ = min(np.sum(tmpz), minZ)
                x[j,i] = np.sum(tmpr) * np.cos(ator)
                y[j,i] = np.sum(tmpr) * np.sin(ator)
                z[j,i] = np.sum(tmpz)                
        #fig = mlab.figure(bgcolor=(1,1,1),fgcolor=(0,0,0),size=(600,600))
        surf = mlab.mesh(x,y,z, **kwargs)
        # Change the visualization parameters.
        #surf.actor.property.interpolation = 'phong'
        #surf.actor.property.specular = 01.0
        #surf.actor.property.specular_power = 100
        #surf.scene.light_manager.light_mode = "vtk"
        return x, y, z
    else :
        raise NameError("No such option!")
        print "plottype = cross-section/surface/surface3d"


#------------------------------------------  28  ----------------------------------------------------
def write_winding_coils(winding_surface, theta, zeta, coil_name='coils.winding_surface', currents=None):
    '''
    write down coils on a winding surface
    winding_surface: the filename of winding surface in nescin format;
    theta          : theta points in 2D plane, size = (Ncoils, Npoints);
     zeta          :  zeta points in 2D plane, size = (Ncoils, Npoints);
    coil_name      : the filename of output coils file;
    currents       : current in each coil, size=(Ncoils), if None, currents = 1E3;

    return : coil class for visualization
    '''
    tmp  = np.shape(theta)
    tmp2 = np.shape( zeta)
    assert tmp == tmp2
    
    if len(tmp) == 1 : # one coil
        Ncoils = 1
        Npoints = tmp[0]
    elif len(tmp) ==2 : # several coils
        Ncoils = tmp[0]
        Npoints = tmp[1]
    else :
        raise ValueError("theta should be in 1/2 dimension with (Ncoils,Npoints).")
    
    if currents is None:
        currents = np.zeros(Ncoils)
        currents = 1E3
    else:
        assert len(currents) == Ncoils

    # read winding surface
    with open(winding_surface, 'r') as f:
        line = ''
        while "np     iota_edge       phip_edge       curpol" not in line:
            line = f.readline()
        line = f.readline()
        nfp = int(line.split()[0])
        #print "nfp:",nfp

        line = ''
        while "------ Current Surface:" not in line:
            line = f.readline()
        line = f.readline()
        line = f.readline()
        #print "Number of Fourier modes in coil surface from nescin file: ",line
        num = int(line)
        plas = np.zeros(num, dtype=[('m',np.float64), ('n', np.float64), #m,n saving as double
                                         ('Rbc', np.float64), ('Zbs', np.float64),
                                         ('Rbs', np.float64), ('Zbc', np.float64) ])
        line = f.readline() #skip one line
        line = f.readline() #skip one line
        for i in range(num):
            line = f.readline()
            plas[i] = tuple([float(j) for j in line.split()])
        plas['n'] *= nfp    
    
    # coil data in real space
    coildata = np.ndarray((Ncoils,),dtype=np.object)
    for icoil in range(Ncoils):
        coildata[icoil] = coil()
        coildata[icoil].I = currents[icoil]
        coildata[icoil].x = np.zeros(Npoints)
        coildata[icoil].y = np.zeros(Npoints)
        coildata[icoil].z = np.zeros(Npoints)
        coildata[icoil].group = icoil+1
        coildata[icoil].name = 'WS_coil'
        for ipoint in range(Npoints) :
            tmpr = plas['Rbc']*np.cos(plas['m']*theta[icoil, ipoint]+plas['n']*zeta[icoil, ipoint]) + \
                   plas['Rbs']*np.sin(plas['m']*theta[icoil, ipoint]+plas['n']*zeta[icoil, ipoint])
            tmpz = plas['Zbc']*np.cos(plas['m']*theta[icoil, ipoint]+plas['n']*zeta[icoil, ipoint]) + \
                   plas['Zbs']*np.sin(plas['m']*theta[icoil, ipoint]+plas['n']*zeta[icoil, ipoint])
            r = np.sum(tmpr) # r value at ipont
            z = np.sum(tmpz) # r value at ipont
            coildata[icoil].x[ipoint] = r*np.cos(zeta[icoil, ipoint])
            coildata[icoil].y[ipoint] = r*np.sin(zeta[icoil, ipoint])
            coildata[icoil].z[ipoint] = z
    # write coils
    write_coils(coildata, coil_name, nfp)
    print "Write coils to ", coil_name
    return coildata
    
'''
    
#------------------------------------------  23  ----------------------------------------------------
def scan_para(input
'''
#------------------------------------------  29  ----------------------------------------------------
def read_winding_surface(filename, filetype='nescoil', nfp=1):
    '''
    The function read winding surface file in FOCUS format and return
    a structured np.array with [n, m, Rbc, Rbs, Zbc, Zbs]

    input arguments:
       filename: path to the file
       filetype: either 'nescoil' or 'coilopt'
    
    return
       a numpy structured array containing 'n', 'm','Rbc', 'Rbs', 'Zbc','Zbs'
    '''
    if filetype == 'nescoil': 
        with open(filename, 'r') as f:
            line = ''
            while "np     iota_edge       phip_edge       curpol" not in line:
                line = f.readline()
            line = f.readline()
            nfp = int(line.split()[0])
            print "nfp:",nfp

            line = ''
            while "------ Current Surface:" not in line:
                line = f.readline()
            line = f.readline()
            line = f.readline()
            print "Number of Fourier modes in coil surface from nescin file: ",line
            num = int(line)
            plas = np.zeros(num, dtype=[('m',np.float64), ('n', np.float64), #m,n saving as double
                                             ('Rbc', np.float64), ('Zbs', np.float64),
                                             ('Rbs', np.float64), ('Zbc', np.float64) ])
            line = f.readline() #skip one line
            line = f.readline() #skip one line
            for i in range(num):
                line = f.readline()
                plas[i] = tuple([float(j) for j in line.split()])
            
    elif filetype == 'coilopt':
        # fast counting no. of lines
        def file_len(fname):
            with open(fname) as f:
                for i, l in enumerate(f):
                    pass
            return i + 1
        num = file_len(filename) # number of lines
        plas = np.zeros(num, dtype=[('m',np.float64), ('n', np.float64), #m,n saving as double
                                    ('Rbc', np.float64), ('Zbs', np.float64),
                                    ('Rbs', np.float64), ('Zbc', np.float64) ])
        with open(filename, 'r') as f:
            for i in range(num):
                line = f.readline()
                plas[i] = tuple([float(j) for j in line.split()]+[0.0, 0.0])
    else:
        raise ValueError('Invalid option for filetype. Either nescoil or coilopt.')

    plas['n'] *= nfp
    plas['n'] *= -1
    return plas

#------------------------------------------  30  ----------------------------------------------------
def booz2focus(booz_file, ns=-1, focus_file='plasma.boundary', tol=10E-6, Nfp=1):
    '''
    convert BOOZ_XFORM output into FOCUS format plasma surface (in Boozer coordinates)

    input arguments:
          booz_file : boozmn_xxx.nc Netcdf file of BOOZ_XFORM output
          ns        : the specific flux surface you want to convert, default: -1
          focus_file: writing FOCUS format input plasma
    '''
    booz = ncdata.open_dataset(booz_file)
    mn = int(booz['mnboz_b'].values)
    xm  = np.array(booz['ixm_b'])
    xn  = np.array(booz['ixn_b']) / Nfp
    rbc = np.array(booz['rmnc_b'][ns,:])
    #rbs = np.zeros(mn)
    zbs = np.array(booz['zmns_b'][ns,:])
    #zbc = np.zeros(mn)
    pmns = np.array(booz['pmns_b'][ns,:])
    #pmnc = np.zeros(mn)

    # Nfp = 1
    Nbnf = 0

    amn = 0
    for imn in range(mn):
        if (abs(rbc[imn])+abs(zbs[imn]+abs(pmns[imn]))) > tol :
            amn += 1 # number of nonzero coef.
    with open(focus_file, 'w') as fofile:
        fofile.write('# bmn   bNfp   nbf '+'\n')
        fofile.write("{:d} \t {:d} \t {:d} \n".format(amn, Nfp, Nbnf))
        fofile.write('#plasma boundary'+'\n')
        fofile.write('# n m Rbc Rbs Zbc Zbs Pmnc Pmns'+'\n')
        for imn in range(mn):
            if (abs(rbc[imn])+abs(zbs[imn]+abs(pmns[imn]))) > tol :
                fofile.write("{:4d}  {:4d} \t {:23.15E}  {:12.5E}  {:12.5E} {:23.15E} {:12.5E}  {:23.15E} \n"
                             .format(xn[imn], xm[imn], rbc[imn], 0.0, 0.0, zbs[imn], 0.0, pmns[imn]))
        fofile.write("#Bn harmonics \n")
        fofile.write('# n m bnc bns'+'\n')          
    print "Finished write FOCUS input file at ", focus_file
    return
    '''
    npol = 128; ntor = 180
    xx = np.zeros([npol,ntor])
    yy = np.zeros([npol,ntor])
    zz = np.zeros([npol,ntor])

    for i in range(ntor):
        ator = zeta + i*(zeta1-zeta)/(ntor-1) #zeta
        for j in range(npol):
            apol = j*2*np.pi/(npol-1) #theta
            sinmn = np.sin(xm*apol-xn*ator) 
            cosmn = np.cos(xm*apol-xn*ator)
            # tmpr = rbc*cosmn + rbs*sinmn
            # tmpz = zbc*cosmn + zbs*sinmn
            # tmpp = pmnc*cosmn + pmns*sinmn
            
            p = np.sum(pmns*sinmn)
            r = np.sum(rbc *cosmn)
            z = np.sum(zbs *sinmn)
            xx[j,i] = r*np.cos(ator+p)  # somehow here is plus 
            yy[j,i] = r*np.sin(ator+p)  #
            zz[j,i] = z

    def TwoDFourier(mm, nn, xc, xs, apol, ator ):
        assert len(mm)==len(nn)==len(xc)==len(xs)
        tmpx = xc*np.cos(mm*apol-nn*ator) + xs*np.sin(mm*apol-nn*ator) 
        return  np.sum(tmpx)
    

    def TwoDFourierSurf(mm, nn, xc, xs, zeta=0.0, zeta1=np.pi*2, npol=360, ntor=360):
        assert len(mm)==len(nn)==len(xc)==len(xs)
        x=np.zeros((npol,ntor))

        for i in range(ntor):
            ator = zeta + i*(zeta1-zeta)/(ntor-1) #zeta
            for j in range(npol):
                apol = j*2*np.pi/(npol-1) #theta
                tmpx = xc*np.cos(mm*apol-nn*ator) \
                       + xs*np.sin(mm*apol-nn*ator) 
                x[j,i] = np.sum(tmpx)
        return x
     '''
    
#------------------------------------------  31  ----------------------------------------------------

def plot_focus_poincare(focus_data, color=None, dotsize=0.1, plot_iota=False):
    '''
    Poincare plots in FOCUS
    '''
    # poincare plots
    if color == None:
        colors = cm.rainbow(np.linspace(1, 0, focus_data.pp_ns))
    else :
        colors = [color]*focus_data.pp_ns

    for i in range(focus_data.pp_ns):
        plt.scatter(focus_data.ppr[:,i], focus_data.ppz[:,i], s=dotsize, color=colors[i])
    plt.axis('equal')
    plt.xlabel('R [m]',fontsize=20)
    plt.ylabel('Z [m]',fontsize=20)
    plt.xticks(fontsize=16)
    plt.yticks(fontsize=16)

    # plot iota
    if plot_iota:
        r = focus_data.ppr[0,:]
        plt.figure()
        plt.plot(r, focus_data.iota, marker='s')
        plt.xlabel('R [m]',fontsize=20)
        plt.ylabel(r'$\iota$',fontsize=20)
        plt.xticks(fontsize=16)
        plt.yticks(fontsize=16)
    return

#------------------------------------------  32  ----------------------------------------------------

def plot_dipole( o, m ):
    o = np.array(o)
    m = np.array(m)
    l = 0.1
    w = 0.05
    h = 0.02
    n = m / np.linalg.norm(m)  # unit normal vector
    y = 1.0
    a = np.array([o[0], y, n[1]/n[2]*(y-o[1])]) # one plane vector
    a = a / np.linalg.norm(a)
    b = np.cross(a,m)
    
    mid = np.zeros([3,4])
    bot = np.zeros([3,4])
    top = np.zeros([3,4])

    ot = o + l/2*n
    ob = o - l/2*n

    mid[:,0] = o + w/2*a + h/2*b
    mid[:,1] = o + w/2*a - h/2*b
    mid[:,2] = o - w/2*a - h/2*b
    mid[:,3] = o - w/2*a + h/2*b
    
    bot[:,0] = ob + w/2*a + h/2*b
    bot[:,1] = ob + w/2*a - h/2*b
    bot[:,2] = ob - w/2*a - h/2*b
    bot[:,3] = ob - w/2*a + h/2*b   

    top[:,0] = ot + w/2*a + h/2*b
    top[:,1] = ot + w/2*a - h/2*b
    top[:,2] = ot - w/2*a - h/2*b
    top[:,3] = ot - w/2*a + h/2*b

    return
#------------------------------------------  32  ----------------------------------------------------
class dipole(object):
    '''
    dipole class
    '''
    def __init__(self, **kwargs):
        '''
        Initialize empty class
        '''
        self.num = 0 # total number of dipoles
        self.nfp = 1 # toroidal_periodicity
        self.momentq = 1 # q expotent
        self.sp_switch = False # switch to indicate if using spherical coordinates
        self.xyz_switch = False # switch to indicate if using spherical coordinates
        self.old = False # old format or new
        self.symmetry = 1 # 0: no symmetry; 1: periodicity; 2: stellarator symmetry (+periodicity)
        if 'ox' in kwargs:
            self.ox = kwargs['ox']
            self.oy = kwargs['oy']
            self.oz = kwargs['oz']
            self.mm = kwargs['mm']
            self.mt = kwargs['mt']
            self.mp = kwargs['mp']
            self.pho = kwargs['pho']
            self.momentq = kwargs['momentq']
            self.Ic = kwargs['Ic']
            self.Lc = kwargs['Lc']
            self.num = len(self.ox)
            self.sp_switch = True            
        return

    @classmethod
    def read_dipole(cls, filename, **kwargs):
        '''
        read diploes from FOCUS format (new)
        '''
        with open(filename, 'r') as coilfile:
            coilfile.readline()
            line = coilfile.readline().split()
            try:
                momentq = int(line[1])
            except:
                print("Moment Q factor was not read. Default=1.")
                momentq = 1
        data = pd.read_csv(filename, skiprows=3, header=None)
        ox = np.array(data[3], dtype=float)
        oy = np.array(data[4], dtype=float)
        oz = np.array(data[5], dtype=float)
        Ic = np.array(data[6], dtype=int)
        mm = np.array(data[7], dtype=float)
        pho= np.array(data[8], dtype=float)
        Lc = np.array(data[9], dtype=int)
        mp = np.array(data[10], dtype=float)
        mt = np.array(data[11], dtype=float)
        print('Read {:d} dipoles from {:}'.format(len(ox), filename))
        return cls(ox=ox, oy=oy, oz=oz, Ic=Ic, mm=mm, Lc=Lc, mp=mp, mt=mt, pho=pho, momentq=momentq)

    @classmethod
    def read_dipole_old(cls, filename, zeta=0.0, zeta1=np.pi*2, **kwargs):
        '''
        read diploes from FOCUS format (old)
        '''
        ox = []; oy = []; oz = [];
        mm = []; mp = []; mt = [];
        Ic = []; Lc = []
        with open(filename, 'r') as coilfile:
            coilfile.readline()
            Ncoils = int(coilfile.readline())
            for icoil in range(Ncoils):
                coilfile.readline()
                coilfile.readline()
                linelist = coilfile.readline().split()
                if int(linelist[0]) == 3 : # central current and background Bz
                    coilfile.readline()
                    linelist = coilfile.readline().split() 
                elif int(linelist[0]) == 2 : # dipoles
                    coilfile.readline()
                    linelist = coilfile.readline().split()
                    r, phi = xy2rp(float(linelist[1]), float(linelist[2]))
                    if phi>=zeta and phi<=zeta1:
                        Lc.append(  int(linelist[0]))
                        ox.append(float(linelist[1]))
                        oy.append(float(linelist[2]))
                        oz.append(float(linelist[3]))
                        Ic.append(  int(linelist[4]))
                        mm.append(float(linelist[5]))
                        mt.append(float(linelist[6]))
                        mp.append(float(linelist[7]))
                elif int(linelist[0]) == 1 : # Fourier coils
                    for i in range(11):
                        coilfile.readline()
                else :
                    raise ValueError('Invalid coiltype = {:d}.'.format(int(linelist[0])))
        nc = len(ox)
        if nc == 0 :
            print('Warning: no dipoles was read from '+filename)
            return
        print('Read {:d} dipoles from {:}. Please manually set self.old=True.'.format(nc, filename))
        ox = np.array(ox)
        oy = np.array(oy)
        oz = np.array(oz)
        mm = np.array(mm)
        mt = np.array(mt)
        mp = np.array(mp)
        Lc = np.array(Lc)
        Ic = np.array(Ic)
        pho = np.ones_like(ox)
        momentq = 1
        return cls(ox=ox, oy=oy, oz=oz, Ic=Ic, mm=mm, Lc=Lc, mp=mp, mt=mt, pho=pho, momentq=momentq)

    def sp2xyz(self):
        '''
        spherical coordinates to cartesian coordinates
        '''
        assert self.sp_switch == True, "You are not using spherical coordinates"
        if self.old:
            self.mx = self.mm * np.sin(self.mt) * np.cos(self.mp) 
            self.my = self.mm * np.sin(self.mt) * np.sin(self.mp) 
            self.mz = self.mm * np.cos(self.mt)
        else :
            self.mx = self.mm * self.pho**self.momentq * np.sin(self.mt) * np.cos(self.mp) 
            self.my = self.mm * self.pho**self.momentq * np.sin(self.mt) * np.sin(self.mp) 
            self.mz = self.mm * self.pho**self.momentq * np.cos(self.mt)
        self.xyz_switch = True
        return

    def xyz2sp(self):
        '''
        cartesian coordinates to spherical coordinates
        '''
        assert self.xyz_switch == True, "You are not using cartesian coordinates"
        if self.old :
            self.mm = np.sqrt(self.mx*self.mx + self.my*self.my + self.mz*self.mz)
            #self.pho = np.ones_like(self.mm)
            #self.momentq = 1
        else :
            self.pho = np.power(np.sqrt(self.mx*self.mx + self.my*self.my + self.mz*self.mz)/self.mm, 1.0/self.momentq)
        self.mp = np.arctan2(self.my, self.mx)
        self.mt = np.arccos(self.mz/(self.mm*self.pho**self.momentq))
        self.sp_switch = True
        return   

    def write_dipole(self, filename, unique=False):
        '''
        write diploes from FOCUS format
        '''
        if not self.sp_switch:
            self.xyz2sp()
        with open(filename, 'w') as wfile :
            wfile.write(" # Total number of coils,  momentq \n")
            if unique:
                wfile.write("{:6d},  {:4d}\n".format(self.num/self.nfp, self.momentq))
            else :
                wfile.write("{:6d},  {:4d}\n".format(self.num, self.momentq))
            if self.old:
                for icoil in range(self.num):
                    if unique:
                        if np.mod(icoil, self.nfp)==0:
                            continue
                    wfile.write("#-----------------{}---------------------------\n".format(icoil+1))
                    wfile.write("#coil_type     coil_name \n")
                    wfile.write("   {:3d}  {:1d}  pm_{:010d}\n".format(2, 1, icoil+1))
                    wfile.write("#  Lc  ox   oy   oz  Ic  I  mt  mp \n")
                    wfile.write("{:6d} {:23.15E} {:23.15E} {:23.15E} {:6d} {:23.15E} {:23.15E} {:23.15E}\n"\
                       .format(self.Lc[icoil], self.ox[icoil], self.oy[icoil], self.oz[icoil], \
                                   self.Ic[icoil], self.mm[icoil], self.mt[icoil], self.mp[icoil] ))
            else:
                wfile.write('#coiltype, symmetry,  coilname,  ox,  oy,  oz,  Ic,  M_0,  pho,  Lc,  mp,  mt \n')
                for i in range(self.num):
                    if unique:
                        if np.mod(i, self.nfp)==0:
                            continue
                    wfile.write(" 2, {:1d}, pm_{:010d}, {:15.8E}, {:15.8E}, {:15.8E}, {:2d}, {:15.8E}," \
                   "{:15.8E}, {:2d}, {:15.8E}, {:15.8E} \n".format(self.symmetry, i, self.ox[i], self.oy[i], self.oz[i], 
                   self.Ic[i], self.mm[i], self.pho[i], self.Lc[i], self.mp[i], self.mt[i]))
        return
    
    def write_vtk(self, vtkname, dim=(1), **kwargs):
        if not self.xyz_switch:
            self.sp2xyz() 
        dim = np.atleast_1d(dim)
        if len(dim) == 1: # save as points
            print "write VTK as points"
            data={"mx":self.mx, "my":self.my, "mz":self.mz}
            if not self.old:
                data.update({"rho":self.pho**self.momentq})
            data.update(kwargs)
            pointsToVTK(vtkname, self.ox, self.oy, self.oz, data=data)#.update(kwargs))
        else : # if manually close the gap
            assert len(dim)==3
            print "write VTK as closed surface"
            phi = 2*np.pi/self.nfp
            def map_toroidal(vec):
                rotate = np.array([[  np.cos(phi), np.sin(phi), 0], \
                                   [ -np.sin(phi), np.cos(phi), 0], \
                                   [                0,               0, 1]])
                return np.matmul(vec, rotate)
            nr, nz, nt = dim
            data_array = {"ox":self.ox, "oy":self.oy, "oz":self.oz, \
                          "mx":self.mx, "my":self.my, "mz":self.mz, \
                          "Ic":self.Ic, "rho":self.pho**self.momentq}
            data_array.update(kwargs)
            for key in list(data_array.keys()):
                new_vec = np.zeros((nr, nz+1, nt+1))
                for ir in range(nr):
                    new_vec[ir,:,:] = map_matrix(np.reshape(data_array[key], dim)[ir,:,:])
                data_array[key] = new_vec
            ox = np.copy(data_array['ox'])
            oy = np.copy(data_array['oy'])
            oz = np.copy(data_array['oz'])   
            del data_array['ox']
            del data_array['oy']
            del data_array['oz'] 
            if self.nfp>1 :
                for ir in range(nr):
                    xyz = map_toroidal(np.transpose([ox[ir,0,:], oy[ir,0,:], oz[ir,0,:]]))
                    ox[ir,nz,:] = xyz[:,0]
                    oy[ir,nz,:] = xyz[:,1]
                    oz[ir,nz,:] = xyz[:,2]
                    moment = map_toroidal(np.transpose([data_array['mx'][ir,0,:],
                                                        data_array['my'][ir,0,:], 
                                                        data_array['mz'][ir,0,:]]))
                    data_array['mx'][ir,nz,:] = moment[:,0]
                    data_array['my'][ir,nz,:] = moment[:,1]
                    data_array['mz'][ir,nz,:] = moment[:,2]
            gridToVTK(vtkname, ox, oy, oz, pointData=data_array)
            return
            ox = np.zeros((nr, nz+1, nt+1))
            oy = np.zeros_like(ox)
            oz = np.zeros_like(ox)
            mx = np.zeros_like(ox)
            my = np.zeros_like(ox)
            mz = np.zeros_like(ox)
            rho = np.zeros_like(ox)
            Ic = np.zeros_like(ox)
            for ir in range(nr):
                ox[ir,:,:] = map_matrix(np.reshape(self.ox, dim)[ir,:,:])
                oy[ir,:,:] = map_matrix(np.reshape(self.oy, dim)[ir,:,:])
                oz[ir,:,:] = map_matrix(np.reshape(self.oz, dim)[ir,:,:])
                mx[ir,:,:] = map_matrix(np.reshape(self.mx, dim)[ir,:,:])
                my[ir,:,:] = map_matrix(np.reshape(self.my, dim)[ir,:,:])
                mz[ir,:,:] = map_matrix(np.reshape(self.mz, dim)[ir,:,:])
                rho[ir,:,:] = map_matrix(np.reshape(self.pho**self.momentq, dim)[ir,:,:])
                Ic[ir,:,:] = map_matrix(np.reshape(self.Ic, dim)[ir,:,:])  
                if self.nfp == 1:
                    continue # map_matrix is enough for 1 period
                # correct toroidal direction
                xyz = map_toroidal(np.transpose([ox[ir,0,:], oy[ir,0,:], oz[ir,0,:]]))
                ox[ir,nz,:] = xyz[:,0].copy()
                oy[ir,nz,:] = xyz[:,1].copy()
                oz[ir,nz,:] = xyz[:,2].copy()
                # correct toroidal direction
                moment = map_toroidal(np.transpose([mx[ir,0,:], my[ir,0,:], mz[ir,0,:]]))
                mx[ir,nz,:] = moment[:,0].copy()
                my[ir,nz,:] = moment[:,1].copy()
                mz[ir,nz,:] = moment[:,2].copy()
            data = {"mx":mx, "my":my, "mz":mz, "rho":rho, "Ic":Ic}
            data.update(kwargs)
            gridToVTK(vtkname, ox, oy, oz, pointData=data)
        return

    def full_period(self, nfp=1):
        """
        map from one period to full periods
        """
        assert nfp>=1
        self.nfp = nfp
        if not self.xyz_switch:
            self.sp2xyz() 
        xyz = toroidal_period(np.transpose([self.ox, self.oy, self.oz]), self.nfp)
        self.ox = xyz[:,0].copy()
        self.oy = xyz[:,1].copy()
        self.oz = xyz[:,2].copy()
        moment = toroidal_period(np.transpose([self.mx, self.my, self.mz]), self.nfp)
        self.mx = moment[:,0].copy()
        self.my = moment[:,1].copy()
        self.mz = moment[:,2].copy()
        self.mm = np.tile(self.mm, self.nfp)
        self.pho = np.tile(self.pho, self.nfp)
        self.Ic = np.tile(self.Ic, self.nfp)
        self.Lc = np.tile(self.Lc, self.nfp)
        self.num *= self.nfp        
        return

    def change_momentq(self, newq):
        """
        change the q factor for density function
        """
        assert newq>0
        pho = self.pho**self.momentq
        self.momentq = newq
        self.pho = np.power(pho, 1.0/newq)
        return

    def plot_pho_profile(self, nrange=10, nofigure=False, **kwargs):
        pho = self.pho**self.momentq
        zone = np.linspace(0, 1, nrange+1, endpoint=True)
        count = []
        for i in range(nrange-1):
            count.append(((pho>=zone[i]) & (pho<zone[i+1])).sum())
        count.append(((pho>=zone[nrange-1]) & (pho<=zone[nrange])).sum())
        count = np.array(count)
        if not nofigure:
            if plt.get_fignums():
                fig = plt.gcf()
                ax = plt.gca()
            else :
                fig, ax = plt.subplots()
            plt.bar(zone[:-1], count/float(self.num), width=1.0/nrange, **kwargs)
            ax.set_xlabel('rho', fontsize=15)
            ax.set_ylabel('fraction', fontsize=15)
            plt.xticks(fontsize=14)
            plt.yticks(fontsize=14)
        return count

    def __del__(self):
        class_name = self.__class__.__name__

def plot_focus_dipole(filename, cube=False, projection=False, scale_factor=1.0, 
                      tol=10.0, zeta=0.0, zeta1=np.pi*2, **kwargs):
    ox = [] ; oy = [] ; oz = []
    mx = [] ; my = [] ; mz = [] ; mm = []
    with open(filename, 'r') as coilfile:
        coilfile.readline()
        Ncoils = int(coilfile.readline())
        #print "Read {} coils.".format(Ncoils)

        for icoil in range(Ncoils):
            coilfile.readline()
            coilfile.readline()

            linelist = coilfile.readline().split()
            if int(linelist[0]) == 3 :
                coilfile.readline()
                linelist = coilfile.readline().split()
                if float(linelist[1]) > 0:
                    mlab.quiver3d( 0, 0, -1, 0, 0, 2, line_width = 2.5, mode='arrow', **kwargs)
                elif float(linelist[1]) < 0:
                    mlab.quiver3d( 0, 0,  1, 0, 0,-2, line_width = 2.5, mode='arrow', **kwargs)                    
            elif int(linelist[0]) == 2 :
                coilfile.readline()
                linelist = coilfile.readline().split()
                # print(linelist)
                r, phi = xy2rp(float(linelist[1]), float(linelist[2]))
                if phi>zeta and phi<zeta1:
                    ox.append(float(linelist[1]))
                    oy.append(float(linelist[2]))
                    oz.append(float(linelist[3]))
                    mm.append(float(linelist[5]))
                    mt = float(linelist[6]) 
                    mp = float(linelist[7])

                    mx.append(np.sin(mt) * np.cos(mp) * np.sign(mm[-1]))
                    my.append(np.sin(mt) * np.sin(mp) * np.sign(mm[-1]))
                    mz.append(np.cos(mt) * np.sign(mm[-1]))
            elif int(linelist[0]) == 1 :
                for i in range(11):
                    coilfile.readline()
            else :
                raise ValueError('Invalid coiltype = {:d}.'.format(int(linelist[0])))
    nc = len(ox)
    if nc == 0 :
        return
    ox = np.array(ox) ; oy = np.array(oy) ; oz = np.array(oz)
    mx = np.array(mx) ; my = np.array(my) ; mz = np.array(mz) ; mm = np.array(mm)
    if projection:
        plt.scatter(np.sqrt(ox*ox+oy*oy), oz, **kwargs)
    else :
        if cube:
            mlab.points3d(ox, oy, oz, mode='cube', scale_factor=0.02, color=(0.75, 0.75, 0.75))
        mlab.quiver3d( ox, oy, oz, mx, my, mz, scalars=mm, mode='arrow', **kwargs)#line_width = 2.5, scale_factor=scale_factor  )
    return
'''
                if mm < 0:
                    m = -1.0
                else :
                    m = 1.0
                # m = np.linalg.norm(np.array([mx,my,mz]))
                if np.sqrt((ox*ox+oy*oy+oz*oz)) < tol :
                    if projection :
                        plt.scatter(np.sqrt(ox*ox+oy*oy), oz, s=2.0, color='b')
                    else :
                        mlab.points3d(ox, oy, oz, mode='cube', color=(0,0,1), scale_factor=0.1)
                        mlab.quiver3d( ox, oy, oz, mx/m, my/m, mz/m, line_width = 2.5, scalars=mm, mode='arrow')
                else :
                    print "{:d}-th dipole outside the domain: ox={:12.5E}, oy={:12.5E}, oz={:12.5E}".format(icoil+1, ox, oy, oz)
           
'''
def dipole2vtk(filename, vtkname, nr, nz, nt, nfp=1, winding=None):
    ox = np.zeros((nr, nz*nfp+1, nt+1))
    oy = np.zeros_like(ox)
    oz = np.zeros_like(ox)
    mx = np.zeros_like(ox)
    my = np.zeros_like(ox)
    mz = np.zeros_like(ox)
    if winding :
        norm = np.zeros_like(ox)
    na = nz*nfp
    nb = nt
    with open(filename, 'r') as coilfile:
        coilfile.readline()
        Ncoils = int(coilfile.readline())
        # assert Ncoils==nr*nz*nt*nfp
        # print "Read {} coils.".format(Ncoils)

        for ir in range(nr):
            for iz in range(nz):
                for it in range(nt):
                    for ip in range(nfp):
                        coilfile.readline()
                        coilfile.readline()
                        linelist = coilfile.readline().split()
                        if int(linelist[0]) == 3 :
                            for i in range(2):
                                coilfile.readline()                  
                        elif int(linelist[0]) == 2 :
                            coilfile.readline()
                            linelist = coilfile.readline().split()
                            # print(linelist)
                            r, phi = xy2rp(float(linelist[1]), float(linelist[2]))
                            ox[ir, iz+ip*nz, it] = float(linelist[1])
                            oy[ir, iz+ip*nz, it] = float(linelist[2])
                            oz[ir, iz+ip*nz, it] = float(linelist[3])
                            mm = float(linelist[5])
                            mt = float(linelist[6]) 
                            mp = float(linelist[7])
                            mx[ir, iz+ip*nz, it] = mm*(np.sin(mt) * np.cos(mp))
                            my[ir, iz+ip*nz, it] = mm*(np.sin(mt) * np.sin(mp))
                            mz[ir, iz+ip*nz, it] = mm*(np.cos(mt))
                        elif int(linelist[0]) == 1 :
                            for i in range(11):
                                coilfile.readline()
                        else :
                            raise ValueError('Invalid coiltype = {:d}.'.format(int(linelist[0])))
            for i in [ox, oy, oz, mx, my, mz] : # close the gap
                i[ir,  na,0:nb] = i[ir,0   ,0:nb]
                i[ir,0:na,  nb] = i[ir,0:na,0   ]        
                i[ir,  na,  nb] = i[ir,0   ,0   ]
            if winding is not None:
                regcoilout = winding+'{:04d}'.format(ir)+'.nc'
                f = netcdf.netcdf_file(regcoilout,'r',mmap=False)
                #single_valued_current_potential_thetazeta = f.variables['single_valued_current_potential_thetazeta'][()]
                norm_normal_coil = f.variables['norm_normal_coil'][()]
                norm_normal_coil_full = np.copy(norm_normal_coil)
                for ip in range(nfp-1):
                    norm_normal_coil_full = np.concatenate((norm_normal_coil_full,norm_normal_coil))
                norm[ir, :, :] = map_matrix(norm_normal_coil_full)
                f.close()
        if winding is not None:
            gridToVTK(vtkname, ox, oy, oz, pointData = {"mx":mx, "my":my, "mz":mz, "norm":norm})
        else:
            gridToVTK(vtkname, ox, oy, oz, pointData = {"mx":mx, "my":my, "mz":mz})
        return

#------------------------------------------  33  ----------------------------------------------------
def cp2vtk(filename, vtkname, nr, nz, nt, nfp=1, lambda_arr=None, max_phi=None):
    ox = np.zeros((nr, nz*nfp+1, nt+1))
    oy = np.zeros_like(ox)
    oz = np.zeros_like(ox)
    phi = np.zeros_like(ox)
    if lambda_arr is None:
        lambda_arr = -1*np.ones(nr,dtype=int)
    for ir in range(nr):
        #regcoilout = filename+'_sep={:04d}'.format(ir+offset)+'.nc'
        regcoilout = filename[ir]
        f = netcdf.netcdf_file(regcoilout,'r',mmap=False)
        single_cp = f.variables['single_valued_current_potential_thetazeta'][()][lambda_arr[ir],:,:]
        if max_phi is not None:
            np.clip(single_cp, -max_phi, max_phi, out=single_cp)
        single_cp_full = np.copy(single_cp)
        for ip in range(nfp-1):
            single_cp_full = np.concatenate((single_cp_full,single_cp))
        phi[ir, :, :] = map_matrix(single_cp_full)
        r_coil = f.variables['r_coil'][()]
        ox[ir, :, :] = map_matrix(r_coil[:,:,0])
        oy[ir, :, :] = map_matrix(r_coil[:,:,1])
        oz[ir, :, :] = map_matrix(r_coil[:,:,2])
    gridToVTK(vtkname, ox, oy, oz, pointData = {"phi":phi})
    return phi
        

#------------------------------------------  33  ----------------------------------------------------
def plot_regcoil_potential(regcoilname, ilambda=None, num_contours=10, total=True, **kwargs):
    f = netcdf.netcdf_file(regcoilname,'r',mmap=False)
    nfp = f.variables['nfp'][()]
    ntheta_plasma = f.variables['ntheta_plasma'][()]
    ntheta_coil = f.variables['ntheta_coil'][()]
    nzeta_plasma = f.variables['nzeta_plasma'][()]
    nzeta_coil = f.variables['nzeta_coil'][()]
    nzetal_plasma = f.variables['nzetal_plasma'][()]
    nzetal_coil = f.variables['nzetal_coil'][()]
    theta_plasma = f.variables['theta_plasma'][()]
    theta_coil = f.variables['theta_coil'][()]
    zeta_plasma = f.variables['zeta_plasma'][()]
    zeta_coil = f.variables['zeta_coil'][()]
    zetal_plasma = f.variables['zetal_plasma'][()]
    zetal_coil = f.variables['zetal_coil'][()]
    r_plasma  = f.variables['r_plasma'][()]
    r_coil  = f.variables['r_coil'][()]
    xm_coil = f.variables['xm_coil'][()]
    xn_coil = f.variables['xn_coil'][()]
    xm_potential = f.variables['xm_potential'][()]
    xn_potential = f.variables['xn_potential'][()]
    mnmax_coil = f.variables['mnmax_coil'][()]
    chi2_B = f.variables['chi2_B'][()]
    chi2_K = f.variables['chi2_K'][()]
    chi2_Phi = f.variables['chi2_Phi'][()]
    single_valued_current_potential_thetazeta = f.variables['single_valued_current_potential_thetazeta'][()]
    current_potential = f.variables['current_potential'][()]
    Bnormal_from_plasma_current = f.variables['Bnormal_from_plasma_current'][()]
    Bnormal_from_net_coil_currents = f.variables['Bnormal_from_net_coil_currents'][()]
    Bnormal_total = f.variables['Bnormal_total'][()]
    net_poloidal_current_Amperes = f.variables['net_poloidal_current_Amperes'][()]
    phi_mn = f.variables['single_valued_current_potential_mn'][()][ilambda,:]
    lambdas = f.variables['lambda'][()]
    f.close()
    # find optimal ilambda
    if ilambda is None:
        ilambda = np.argmin(np.log(chi2_B) + np.log(chi2_Phi))
        print("ilambda is chosen to be ", ilambda)

    if total:
        current_potential_plot = np.transpose(current_potential[ilambda,:,:])        
    else:
        current_potential_plot = np.transpose(single_valued_current_potential_thetazeta[ilambda,:,:])
    if plt.get_fignums():
        fig = plt.gcf()
        ax = plt.gca()
    else :
        fig, ax = plt.subplots()
    plt.contourf(zeta_coil, theta_coil, current_potential_plot, num_contours, **kwargs)
    cb = plt.colorbar(format='%.1E')
    cb.ax.tick_params(labelsize=12) 
    ax.set_xlabel('zeta', fontsize=15)
    ax.set_ylabel('theta', fontsize=15)
    plt.xticks(fontsize=14)
    plt.yticks(fontsize=14)
    plt.title(r'$\lambda={:12.5E}$'.format(lambdas[ilambda]), fontsize=14)
    print('Total Bn error from current potential is {:12.5E}'.format(chi2_B[ilambda]))
    return current_potential_plot

def read_nescout(filename):
    with open(filename, 'r') as f:
        line = ''
        while "----- Fourier "  not in line:
            line = f.readline() 
        line = f.readline()
        line = f.readline()                                               
        mf = int(line.split()[0])                                          
        nf = int(line.split()[0])
        num_phi = (mf+1)*(2*nf+1)
        print "total num of Phi(m,n) = ", num_phi
        while "curpol" not in line:
            line = f.readline()   
        line = f.readline()       
        nfp = int(line.split()[0])
        print "nfp:",nfp                  
        phi = np.zeros(num_phi, dtype=[('m',np.float64), ('n', np.float64), ('sin', np.float64) ])
        line = ''                         
        while "---- Phi(m,n)" not in line:
            line = f.readline()                                                 
        for i in range(num_phi):
            line = f.readline()
            phi[i] = tuple([float(j) for j in line.split()])
        phi['n'] *= nfp

        return phi

def xy2rp(x, y):
    """Convert (x,y) to (R,phi) in polar coordinate
    """
    R = np.sqrt(x**2 + y**2)
    if   x >  0.0 and y >= 0.0 : # [0,pi/2)
        phi = np.arcsin(y/R)
    elif x <= 0.0 and y >  0.0 : # [pi/2, pi)
        phi = np.arccos(x/R)
    elif x <  0.0 and y <= 0.0 : # [pi, 3/2 pi)
        phi = np.arccos(-x/R) + np.pi
    elif x >= 0.0 and y <  0.0 : # [3/2 pi, 2pi)
        phi = np.arcsin(y/R) + 2*np.pi
    else:
        raise ValueError("Something wrong with your inputs ({:f}, {:f}).".format(x, y))
    return R, phi
def map_matrix(xx):
    """Map matrix to be complete (closed)
    """
    a, b = np.shape(xx)
    new = np.zeros((a+1,b+1))
    new[0:a, 0:b] = xx[0:a, 0:b]
    new[  a, 0:b] = xx[0  , 0:b]
    new[0:a,   b] = xx[0:a, 0  ]
    new[  a,   b] = xx[0  , 0  ]
    return new
    
def fit_focus_lcfs(h5data, isurf=-1, npol=128, ntor=128):
    """Fit a surface from FOCUS fieldline tracing results
    Input arguments:
        h5data : FOCUS hdf5 format output data read by hdf5().
        isurf  : Surface (field-line) label. Defaut is -1 (the last one).
        npol   : poloidal resolution
        ntor   : toroidal resolution
    Return:
        (xx, yy, zz, BB) : two dimentional arrays in Cartesian coordinates
    """
    if not isinstance(h5data, hdf5):
        print h5data, " is not a valid FOCUS hdf5 file."
        return

    xline = h5data.XYZB[isurf, 0, :]
    yline = h5data.XYZB[isurf, 1, :]
    zline = h5data.XYZB[isurf, 2, :]
    Bline = h5data.XYZB[isurf, 3, :]

    xx = np.zeros((npol+1, ntor+1))
    yy = np.zeros((npol+1, ntor+1))
    zz = np.zeros((npol+1, ntor+1))
    BB = np.zeros((npol+1, ntor+1))
    weight = np.zeros((npol+1, ntor+1))   
    chi = np.zeros_like(Bline)
    
    for i in range(1, len(chi)):
        chi[i] = chi[i-1] + (Bline[i] + Bline[i-1])/2 \
            * np.sqrt((xline[i] - xline[i-1])**2 \
                     +(yline[i] - yline[i-1])**2 \
                     +(zline[i] - zline[i-1])**2 )
    Gpol = chi[-1] / (2*np.pi*h5data.pp_maxiter[0])
    zeta = np.mod(chi/Gpol, 2*np.pi)
    teta = np.mod(chi/Gpol*h5data.iota[isurf], 2*np.pi)
    dteta = 2*np.pi/npol
    dzeta = 2*np.pi/ntor
    
    for i in range(len(xline)):
        # locate grid cell
        iteta = int(teta[i]/dteta)
        jzeta = int(zeta[i]/dzeta)
        #if iteta=npol or jzeta=ntor:
        #    print(teta[i], zeta[i])
        #    return
        teta1 =  iteta    * dteta
        zeta1 =  jzeta    * dzeta
        teta2 = (iteta+1) * dteta
        zeta2 = (jzeta+1) * dzeta
        
        # distance to grid points
        d11 = max(np.sqrt( (teta[i]-teta1)**2 + (zeta[i]-zeta1)**2 ), 1E-16)
        d12 = max(np.sqrt( (teta[i]-teta1)**2 + (zeta[i]-zeta2)**2 ), 1E-16)
        d21 = max(np.sqrt( (teta[i]-teta2)**2 + (zeta[i]-zeta1)**2 ), 1E-16)
        d22 = max(np.sqrt( (teta[i]-teta2)**2 + (zeta[i]-zeta2)**2 ), 1E-16)
        
        # inverse distance weight        
        weight[iteta  , jzeta  ] += 1/d11
        weight[iteta  , jzeta+1] += 1/d12
        weight[iteta+1, jzeta  ] += 1/d21
        weight[iteta+1, jzeta+1] += 1/d22
        
        # interpolation
        xx[iteta  , jzeta  ] += xline[i] * 1/d11
        xx[iteta  , jzeta+1] += xline[i] * 1/d12
        xx[iteta+1, jzeta  ] += xline[i] * 1/d21
        xx[iteta+1, jzeta+1] += xline[i] * 1/d22
        
        yy[iteta  , jzeta  ] += yline[i] * 1/d11
        yy[iteta  , jzeta+1] += yline[i] * 1/d12
        yy[iteta+1, jzeta  ] += yline[i] * 1/d21
        yy[iteta+1, jzeta+1] += yline[i] * 1/d22
        
        zz[iteta  , jzeta  ] += zline[i] * 1/d11
        zz[iteta  , jzeta+1] += zline[i] * 1/d12
        zz[iteta+1, jzeta  ] += zline[i] * 1/d21
        zz[iteta+1, jzeta+1] += zline[i] * 1/d22

        BB[iteta  , jzeta  ] += Bline[i] * 1/d11
        BB[iteta  , jzeta+1] += Bline[i] * 1/d12
        BB[iteta+1, jzeta  ] += Bline[i] * 1/d21
        BB[iteta+1, jzeta+1] += Bline[i] * 1/d22        
        
    #return (map_matrix(xx/weight), map_matrix(yy/weight), map_matrix(zz/weight), map_matrix(BB/weight))
    return (xx/weight, yy/weight, zz/weight, BB/weight)
#######
def twoDfourier(teta, zeta, xm, xn, xc, xs):
    assert len(xc)==len(xm)
    data = np.zeros_like(teta)
    for i in range(len(teta)):
        ang = xm*teta[i] - xn*zeta[i]
        data[i] = np.sum(xc*np.cos(ang) + xs*np.sin(ang))
    return data
        
def fit_fourier(data, teta, zeta, xm, xn):
    """Find the best 2D Fourier coefficients to data for given coordinates
    Input:
        data : 1D array including data to be decomposed
        teta : 1D array of poloilda angle set
        zeta : 1D array of toroilda angle set
        xm   : 1D array of poloidal mode number
        xn   : 1D array of toroidal mode number
    Return:
        [xc,xs]: 1D array of cosine & sine harmonics
    """
    def func(x):
        xc = x[0:len(x)/2]
        xs = x[len(x)/2:len(x)]
        new_data = twoDfourier(teta, zeta, xm, xn, xc, xs)
        return np.sum((data-new_data)*(data-new_data))
    def gradient(x):
        xc = x[0:len(x)/2]
        xs = x[len(x)/2:]
        g = np.zeros_like(x)
        new_data = twoDfourier(teta, zeta, xm, xn, xc, xs)
        for i in range(len(xc)):
            g[i] = np.sum(-2.0*(data-new_data)*np.cos(xm[i]*teta - xn[i]*zeta))
            g[i+len(xc)] = np.sum(-2.0*(data-new_data)*np.sin(xm[i]*teta - xn[i]*zeta))
        return g
    xv = np.ones(2*len(xm), dtype=np.float) # initial value
    print(len(xv))
    print(func(xv))
    res = optimize.minimize(func, xv, method='Newton-CG', jac=gradient)
    return res

def plot_spec_kam(filename, ivol=-1, zeta=0.0, zeta1=2*np.pi, color=(1,0,0),style='-', marker=None, width=2.0, lbl='SPEC_interface',npol=128,ntor=128):
    spec = hdf5(filename)
    xm = spec.im
    xn = spec.in1
    
    if plt.get_fignums():
        fig = plt.gcf()
        ax = plt.gca()
    else :
        fig, ax = plt.subplots()

    plt.axis('equal')
    plt.xlabel('R [m]',fontsize=20)
    plt.ylabel('Z [m]',fontsize=20)
    plt.xticks(fontsize=16)
    plt.yticks(fontsize=16)
    plt.tight_layout()
    
    #for ivol in range(spec.Mvol+1):
    rbc = spec.Rbc[ivol,:]
    zbs = spec.Zbs[ivol,:]
    rbs = np.zeros(np.shape(rbc))
    zbc = np.zeros(np.shape(rbc))
    npoints = 361 #number of points
    theta = np.linspace(0,2*np.pi, npoints)
    r = np.zeros(npoints)
    z = np.zeros(npoints)
    for ipoint in range(npoints):
        tmpr = rbc*np.cos(xm*theta[ipoint]-xn*zeta) + rbs*np.sin(xm*theta[ipoint]-xn*zeta)
        r[ipoint] = np.sum(tmpr) #r value at ipont

        tmpz = zbs*np.sin(xm*theta[ipoint]-xn*zeta) + zbc*np.cos(xm*theta[ipoint]-xn*zeta)
        z[ipoint] = np.sum(tmpz) #z value at ipont
    ax.plot(r, z, color=color,linewidth=width,linestyle=style,label=lbl, marker=marker)
    return
def plot_spec_pressure(filename, color='b', style='-', marker=None, width=2.0, lbl='SPEC_pressure'):
    spec = hdf5(filename)
    if plt.get_fignums():
        fig = plt.gcf()
        ax = plt.gca()
    else :
        fig, ax = plt.subplots()
    
    pressure = spec.pressure * spec.pscale / (4*np.pi*1.0E-7)
    for ivol in range(spec.Mvol-1):
        if ivol == 0:
            ax.plot([0, spec.tflux[ivol]],[pressure[ivol], pressure[ivol]],color=color,
                 linewidth=width,linestyle=style,label=lbl, marker=marker)
        else:
            ax.plot([spec.tflux[ivol-1], spec.tflux[ivol]],[pressure[ivol], pressure[ivol]],color=color,
                 linewidth=width,linestyle=style,label=lbl, marker=marker)
            ax.plot([spec.tflux[ivol-1], spec.tflux[ivol-1]],[pressure[ivol-1], pressure[ivol]],color=color,
                    linewidth=width,linestyle=style,label=lbl, marker=marker)
    plt.xlabel('Normalized flux',fontsize=20)
    plt.ylabel('Pressure',fontsize=20)
    plt.xticks(fontsize=16)
    plt.yticks(fontsize=16)
    return
#------------------------------------------  33  ----------------------------------------------------
def check_coil_periodic(coilA, coilB, nfp=2, tol=1.0E-6, current=True, verbose=False):
    """check if two coils are periodic
    coilA, coilB: two coil classes
    nfp: number of field periodicity
    tol: allowable tolerance
    """
    if isinstance(coilA, list):
        coilA = coilA[0]
    #assert isinstance(coilA, coil)
    if isinstance(coilB, list):
        coilB = coilB[0]
    #assert isinstance(coilB, coil)
    
    assert len(coilA.x)==len(coilB.x)

    if current and abs((coilA.I-coilB.I)/coilA.I)>tol:
        if verbose :
            print("coil currents are different.")
        return False
    
    for i in range(len(coilA.x)):
        if abs(coilA.z[i]-coilB.z[i])>tol:
            if verbose: print('index = ', i, ', z_diff=', coilA.z[i]-coilB.z[i])
            return False
        rA, pA = xy2rp(coilA.x[i], coilA.y[i])
        rB, pB = xy2rp(coilB.x[i], coilB.y[i])
        
        if abs(rA-rB)>tol or abs(abs(pA-pB)-2*np.pi/nfp)>tol:
            if verbose: 
                print('index = ', i, ', r_diff=', rA-rB, ', phi_diff=', pA-pB)
                print('A:', coilA.x[i], coilA.y[i], rA, pA)
                print('B:', coilB.x[i], coilB.y[i], rB, pB)
                return False
    return True

#------------------------------------------  33  ----------------------------------------------------
def check_coil_symmetric(coilA, coilB, nfp=1, tol=1.0E-6, current=True, verbose=False):
    """check if two coils are stellarator symmetric
    coilA, coilB: two coil classes
    nfp: number of field periodicity
    tol: allowable tolerance
    """
    if isinstance(coilA, list):
        coilA = coilA[0]
    #assert isinstance(coilA, coil)
    if isinstance(coilB, list):
        coilB = coilB[0]
    #assert isinstance(coilB, coil)
    
    assert len(coilA.x)==len(coilB.x)

    if current and abs((coilA.I-coilB.I)/coilA.I)>tol:
        if verbose :
            print("coil currents are different.")
        return False
    
    for i in range(len(coilA.x)):
        rA, pA = xy2rp(coilA.x[i], coilA.y[i])
        pB = 2*np.pi/nfp - pA
        xB = rA*np.cos(pB)
        yB = rA*np.sin(pB)
        zB = -coilA.z[i]
        
        iB = np.argmin(np.abs(coilB.x-xB)+np.abs(coilB.y-yB))
        if abs(xB-coilB.x[iB])>tol or abs(yB-coilB.y[iB])>tol or abs(zB-coilB.z[iB])>tol:
            if verbose: print('index = ', i,  ', x_diff=', xB-coilB.x[iB], ', y_diff=', yB-coilB.y[iB], ', z_diff=', zB-coilB.z[iB])
            return False
    return True

#-----------
def check_coilset_symmetric(coilset, nfp, tol=1.0E-6, current=True, verbose=False):
    assert nfp>=1
    num = len(coilset)/(2*nfp) #unique coil number
    check=np.zeros(num, dtype=bool)
    for icoil in range(num):
        if nfp==1:
            jcoil = num*2-icoil-1
            check[icoil] = check_coil_symmetric(coilset[icoil], coilset[jcoil], nfp=nfp, tol=tol, current=current, verbose=verbose)
            if verbose and not check[icoil] :
                print("coil {:} is not periodic with coil {:}.".format(icoil, jcoil, kcoil))
        for ip in range(nfp-1):
            jcoil = num*2-icoil-1
            kcoil = icoil + num*2
            check[icoil] = check_coil_periodic(coilset[icoil], coilset[kcoil], nfp=nfp, tol=tol, current=current, verbose=verbose) or \
                check_coil_symmetric(coilset[icoil], coilset[jcoil], nfp=nfp, tol=tol, current=current, verbose=verbose)
            if verbose and not check[icoil] :
                print("coil {:} is not symmetric or periodic with coil {:} & coil {:}."\
                          .format(icoil, jcoil, kcoil))
    return np.all(check)

def combine_focus_coils(coils_list, output='combined.focus'):
    assert len(coils_list)>1
    total_num = 0
    first = True
    for filename in coils_list:
        tmp = pd.read_csv(filename,delimiter="\n", header=None)
        num = int(tmp[0][1])
        #print num
        total_num += num
        # drop the first two lines
        if first:
            offset = 0
            first = False
            total_coils = tmp
        else:
            offset = 2    
            total_coils = pd.concat([total_coils, pd.DataFrame(tmp[0][offset:])], ignore_index=True)
    # update the total num
    total_coils[0][1] = str(total_num)
    # write output
    total_coils.to_csv(output, header=False, index=False)
    print('total number of coils/dipoles : {:d}'.format(total_num))

def read_regcoil_potential(regcoilname, ilambda=None, total=True, **kwargs):
    f = netcdf.netcdf_file(regcoilname,'r',mmap=False)
    chi2_B = f.variables['chi2_B'][()]
    chi2_K = f.variables['chi2_K'][()]
    chi2_Phi = f.variables['chi2_Phi'][()]
    single_valued_current_potential_thetazeta = f.variables['single_valued_current_potential_thetazeta'][()]
    current_potential = f.variables['current_potential'][()]
    f.close()
    # find optimal ilambda
    if ilambda is None:
        ilambda = np.argmin(np.log(chi2_B) + np.log(chi2_Phi))
        print("ilambda is chosen to be ", ilambda)
    if total:
        current_potential_plot = np.transpose(current_potential[ilambda,:,:])        
    else:
        current_potential_plot = np.transpose(single_valued_current_potential_thetazeta[ilambda,:,:])
    print('Total Bn error from current potential is {:12.5E}'.format(chi2_B[ilambda]))
    return current_potential_plot

# Print iterations progress
def print_progress(iteration, total, prefix='Progress', suffix='Complete', decimals=1, bar_length=60):
    """
    Call in a loop to create terminal progress bar
    @params:
        iteration   - Required  : current iteration (Int)
        total       - Required  : total iterations (Int)
        prefix      - Optional  : prefix string (Str)
        suffix      - Optional  : suffix string (Str)
        decimals    - Optional  : positive number of decimals in percent complete (Int)
        bar_length  - Optional  : character length of bar (Int)
    """
    str_format = "{0:." + str(decimals) + "f}"
    percents = str_format.format(100 * (iteration / float(total)))
    filled_length = int(round(bar_length * iteration / float(total)))
    bar = '█' * filled_length + '-' * (bar_length - filled_length)

    sys.stdout.write('\r%s |%s| %s%s %s' % (prefix, bar, percents, '%', suffix)),

    if iteration == total:
        sys.stdout.write('\n')
    sys.stdout.flush()

#-------------------------map array periodly-----------------------------------
def toroidal_period(vec, nfp=1):
    """
    vec: [x,y,z] data
    Nfp: =1, toroidal number of periodicity
    """
    phi = 2*np.pi/nfp
    vec = np.atleast_2d(vec)
    new_vec = vec.copy()
    for ifp in range(nfp):
        if ifp==0:
            continue
        rotate = np.array([[  np.cos(ifp*phi), np.sin(ifp*phi), 0], \
                           [ -np.sin(ifp*phi), np.cos(ifp*phi), 0], \
                           [                0,               0, 1]])
        new_vec = np.concatenate((new_vec, np.matmul(vec, rotate)))
    return new_vec
